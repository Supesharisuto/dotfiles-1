#+TITLE: Emacs configuration file
#+AUTHOR: Filip Krikava
#+BABEL: :cache yes
#+PROPERTY: header-args :tangle yes :results none :eval yes
#+STARTUP: overview

* Overview
** TODO descrive the idea behind this configuration
** Micro states

| Key     | Micro state      |
|---------+------------------|
| =C-x w= | Windows          |
| =C-x b= | Buffers          |
| =C-x t= | Toggles          |
| =C-x p= | Projects         |
| =C-c &= | Snippets         |
| =M-g=   | Go to            |
| =M-r=   | Expand region    |
| =M-m=   | Multiple cursors |

* Sources
** TODO clean and describe
- http://wikemacs.org/wiki/Starter_Kits
- https://github.com/technomancy/better-defaults/blob/master/better-defaults.el
- http://www.emacs-bootstrap.com/
- https://github.com/a13/emacs.d/blob/master/README.org
- https://github.com/freetonik/emacs-dotfiles/blob/master/init.org
  - emacs podcast guy configuration
- http://pages.sachachua.com/.emacs.d/Sacha.html
  - the emacs girl configuration
- https://github.com/danielmai/.emacs.d/blob/master/config.org
- https://thb.lt/emacs-cheatsheet/
- https://github.com/abo-abo/awesome-emacs
- https://github.com/redguardtoo/emacs.d
- https://github.com/abo-abo/oremacs
- https://github.com/purcell/emacs.d
- https://github.com/trending/emacs-lisp?since=monthly
- https://melpa.org/#/?sort=downloads&asc=false
- https://github.com/sam217pa/emacs-config/blob/develop/init.el
- https://sam217pa.github.io/2016/10/18/context-dependent-keybindings/
- https://bitbucket.org/holgerschurig/emacsconf/src/74d428aa2f9be88b14a503f6c3a816ae7cd13644/helm.org?at=master&fileviewer=file-view-default
  - just a helm configuration
- http://www.matskjesrud.com/emacs.html
- https://old.reddit.com/r/emacs/comments/bk9k7l/tips_and_tricks_for_r_programming_in_academia/
  - about R
- http://juanjose.garciaripoll.com/blog/emacs-wanderlust-email
  - about wunderlust
[[https://github.com/jwiegley/use-package][use-package
]]
** To check
https://github.com/milkypostman/powerline
https://github.com/Fuco1/smartparens

* Basics
** Lexical scoping                                            :experimental:

I like lexical scoping, but not sure if this actually really does anything.

#+BEGIN_SRC emacs-lisp
;;; -*- lexical-binding: t -*-
#+END_SRC
** Global variables

#+BEGIN_SRC emacs-lisp
(defvar fikovnik/my-keys nil
  "The list of keys to be mapped as pairs of keySym and ascii code")

(defvar fikovnik/my-keys-debug nil
  "Toggle my-keys debugging")

(defvar fikovnik/st-dir nil
  "The location of st terminal sources")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq fikovnik/st-dir "~/Projects/st"
      fikovnik/my-keys-debug t
      fikovnik/my-keys '((?\; "XK_semicolon"    ("C" "C-M"))
                         (?:  "XK_colon"        ("C-S" "C-M-S"))
                         (?'  "XK_apostrophe"   ("C" "C-M"))
                         (?\" "XK_quotedbl"     ("C-S" "C-M-S"))
                         (?.  "XK_period"       ("C" "C-M"))
                         (?,  "XK_comma"        ("C" "C-M"))
                         (?=  "XK_equal"        ("C" "C-M"))
                         (?<  "XK_less"         ("C-S" "C-M-S"))
                         (?>  "XK_greater"      ("C-S" "C-M-S"))
                         (??  "XK_question"     ("C-S" "C-M-S"))
                         (?/  "XK_slash"        ("C" "C-M"))
                         (?\\ "XK_backslash"    ("C" "C-M"))
                         (?|  "XK_bar"          ("C-S" "C-M-S"))
                         (?~  "XK_asciitilde"   ("C-S" "C-M-S"))
                         (?`  "XK_grave"        ("C" "C-S"))
                         (?{  "XK_braceleft"    ("C-S" "C-M-S"))
                         (?}  "XK_braceright"   ("C-S" "C-M-S"))
                         (?\] "XK_bracketright" ("C" "C-M"))
                         (?\( "XK_parenleft"    ("C-S" "C-M-S"))
                         (?\) "XK_parenright"   ("C-S" "C-M-S"))
                         (?C  "XK_C"            ("C-S" "C-M-S"))
                         (?X  "XK_X"            ("C-S" "C-M-S"))
                         (?V  "XK_V"            ("C-S" "C-M-S"))
                         (?I  "XK_I"            ("C-S" "C-M-S"))
                         (?M  "XK_M"            ("C-S" "C-M-S"))
                         (?J  "XK_J"            ("C-S" "C-M-S"))
                         (?m  "XK_m"            ("C" "C-M")     (([C-m]) ([C-M-m])))
                         (?i  "XK_i"            ("C" "C-M")     (([C-i]) ([C-M-i])))))
#+END_SRC

- The =C-m=, =C-M-m, =C-i= and =C-M-i= can be bind using symbol =[C-m]=, etc.
  They are not =C-m=, but =<C-m>= from Emacs perspective.
- It would be possible to map as well =C-j= but that is handy for inserting the
  new line literal (using =C-q=) for example for replace.

*** Add =C-<number>= and =C-M-<number>=

#+BEGIN_SRC emacs-lisp
(let ((nums '(1 2 3 4 5 6 7 8 9)))
  (mapc (lambda (x)
          ;; DEC 48 is '0' in ASCII table
          (let* ((code (+ 48 x))
                 (e (list code (format "XK_%d" x) (list "C" "C-M"))))
            (setq fikovnik/my-keys (append fikovnik/my-keys (list e)))))
        nums))
#+END_SRC

** GC threshold

Allow 128MB between GC cycle (defailt is 780kB). Apparently this should make
some operations faster, although I never tested it.

#+BEGIN_SRC emacs-lisp
(setq gc-cons-threshold (* 128 1024 1024))
#+END_SRC
** ST terminal
Treat st terminal as xterm (cf. https://www.gnu.org/software/emacs/manual/html_node/elisp/Terminal_002dSpecific.html)
#+BEGIN_SRC emacs-lisp
(add-to-list 'term-file-aliases (quote ("st" . "xterm")))
#+END_SRC
** Input map in terminal

This section fixes key bindings in Emacs running in a terminal.

*** Overview

There are several problems in handling key events in the current terminals. For
example:
- it is not possible to use modifiers other than =C-= and =M-=,
- the =C-= modifier encodes lower or upper-case letters identically,
- special names for some ASCII characters collide with =C-= modified letters (e.g., a tab is =C-i=),
- there is no reliable way to use multiple modifier keys, other than, =M-S-=,
- some keys cannot be used with =C-= modifier, eg., =;=, =.=, =/=.

The reason for all of this is that there is no standard for these _corner_
cases. There has been a several proposals:
- [[http://www.leonerd.org.uk/hacks/fixterms/][Paul Evan's fixterms]]
- [[https://sw.kovidgoyal.net/kitty/protocol-extensions.html#extensions-to-the-xterm-protocol][Kitty extension to xterm protocol]]
- [[https://github.com/CyberShadow/term-keys][term-keys package]]
- XTerm's [[https://invisible-island.net/xterm/manpage/xterm.html#VT100-Widget-Resources:formatOtherKeys][formatOtherKeys]] and [[https://invisible-island.net/xterm/manpage/xterm.html#VT100-Widget-Resources:modifyOtherKeys][modifyOtherKeys]] classes

I decided to use Paul's fixterm proposition (which is compatible with XTerm's
solution given =formatOtherKeys= is set to 1). It works as follows: for each
key combination that is not expressible in the current schema it will use the
following escape sequence:

#+BEGIN_SRC text
ESC[<key>;<mod>u
#+END_SRC

where
- =key= is the ASCII decimal value of the key
- =mod= is 1 + bitmask encoding of the modifiers
  - =S-= = 1
  - =M-= = 2
  - =C-= = 4

For example, =C-;= sends =\e[59;5u=.

Xterm can do that as well with =formatOtherKeys:1=, which can be verified using:

#+BEGIN_SRC sh :tangle no
xterm -xrm '*modifyOtherKeys:1' -xrm '*formatOtherKeys:1' -e cat -v
#+END_SRC

- With =modifyOtherKeys:2= it can do even =C-m=, =C-j= and =C-i=:
  - =C-m= -- =109;5u=
  - =C-S-m= -- =77;6u=
  - =C-i= -- =105;5u=
  - =C-S-i= -- =73;6u=
  - =C-j= -- =106;5u=
  - =C-S-j= -- =74;5u=
  - =C-`= -- =96;5u=
  - =C-\= -- =92;5u=

For this to work, two things need to be updated:
1. the terminal emulator (st in my case)
2. the emacs's =input-decode-map=

**** Terminal - st

In [[https://st.suckless.org/][st]] (my terminal of choice), one has to modify two places:
1. =mappedkeys= variable in =config.h= which contains a list of
   custom-mapped keys:

   #+BEGIN_SRC c :tangle no
   XK_semicolon
   #+END_SRC

2. =keys= variable in =config.h= containing the actual mapping:

   #+BEGIN_SRC c :tangle no
   {XK_semicolon, ControlMask, "\033[59;5u", 0, 0}
   #+END_SRC

**** Emacs

In emacs we only need to add the corresponding binding into the
=input-decode-map=:

#+BEGIN_SRC emacs-lisp :tangle no
(define-key input-decode-map "\e[59;5u" (kbd "C-;"))
#+END_SRC

**** Notes about upper/lower keys binding

From Emacs _Key Sequence Input_:

#+BEGIN_QUOTE
If an input character is upper-case (or has the shift modifier) and has no
key binding, but its lower-case equivalent has one, then read-key-sequence'
converts the character to lower case. Note that lookup-key' does not perform
case conversion in this way.
#+END_QUOTE
**** Notes about [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Key-Sequences.html#Key-Sequences][Key Sequences]] in Emacs
- The Emacs Lisp representation for a key sequence is a string or vector.
- The =kbd= macro returns a representation of a key sequence using some sort of
  translation.
- It is also possible to bind keys using a vector like =[C-S-M]= which will
  create a =<C-M>= binding, a different from =C-S-M=.
*** Configuration
**** Auxiliary functions

#+BEGIN_SRC emacs-lisp
(defun flatten (list-of-lists)
  (apply #'append list-of-lists))

(defun join (sep lst)
   (mapconcat 'identity lst sep))

 (defun zip (xs ys)
   (if (and (null xs) (null ys)) 
       ()
     (cons (cond
            ((null xs) (cons '(nil) (car ys)))
            ((null ys) (cons (car xs) '(nil)))
            (t (cons (car xs) (car ys))))
           (zip (cdr xs) (cdr ys)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defconst fikovnik/-my-keys-prefix "\033["
  "Escape code sequence prefix")

(defconst fikovnik/-my-keys-suffix "u"
  "Escape code sequence suffix")

(defconst fikovnik/-my-keys-modifiers
  '(("C"     . ("ControlMask"                        5))
    ("C-S"   . ("ControlMask | ShiftMask"            6))
    ("C-M"   . ("ControlMask | Mod1Mask"             7))
    ("C-M-S" . ("ControlMask | Mod1Mask | ShiftMask" 8)))
  "The key modifiers as triplets of st emacs name, st name and code")

(defun fikovnik/-encode-key-mod (key-code mod-code)
  (format "%s%d;%d%s" fikovnik/-my-keys-prefix key-code mod-code fikovnik/-my-keys-suffix))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun fikovnik/-iterate-keys (fun)
  (mapcan
   (lambda (key)
     (let ((key-code (car key))
           (key-sym (cadr key))
           (mods (caddr key))
           (keys-emacs (cadddr key)))
       (mapcar
        (lambda (x)
          (let* ((mod (car x))
                 (key-emacs (cadr x))
                 (mod-info (cdr (assoc mod fikovnik/-my-keys-modifiers))))
            (funcall fun key-code key-sym mod mod-info key-emacs)))
        (zip mods keys-emacs))))
   fikovnik/my-keys))
#+END_SRC

**** Enabling my-keys in st

#+BEGIN_SRC emacs-lisp
(defun fikovnik/-escape-string (s)
  (mapconcat
   (lambda (x)
     (if (and (>= x 32) (<= x 255))
         (format "%c" x)
       (format "\\x%02X" x)))
   (append s nil)
   ""))

(defun fikovnik/-st-encode-keys ()
  (delete-dups
   (fikovnik/-iterate-keys
    (lambda (key-code key-sym mod mod-info key-emacs)
      (let ((mod-sym (car mod-info))
            (mod-code (cadr mod-info)))
        (format "{%s, %s, \"%s\", 0, 0}"
                key-sym
                mod-sym
                (fikovnik/-escape-string (fikovnik/-encode-key-mod key-code mod-code))))))))

(defun fikovnik/-st-encode-mapped-keys ()
  (delete-dups
   (fikovnik/-iterate-keys
    (lambda (key-code key-sym mod mod-info key-emacs)
      (format "%s" key-sym)))))

(defun fikovnik/st-sync-mapped-keys ()
  (interactive)
  (with-temp-buffer
    (insert (concat (join ",\n" (fikovnik/-st-encode-keys)) ",\n"))
    (write-region (point-min) (point-max) (expand-file-name "my-keys.h" fikovnik/st-dir)))

  (with-temp-buffer
    (insert (concat (join ",\n" (fikovnik/-st-encode-mapped-keys)) ",\n"))
    (write-region (point-min) (point-max) (expand-file-name "my-mapped-keys.h" fikovnik/st-dir))))
#+END_SRC

**** Enabling my-keys in Emacs

Make Emacs aware of these new keys using the [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Translation-Keymaps.html][input-decode-map]].

#+BEGIN_SRC emacs-lisp
(defun fikovnik/emacs-encode-keys ()
  (fikovnik/-iterate-keys
   (lambda (key-code key-sym mod mod-info key-emacs)
     (let* ((mod-code (cadr mod-info))
            (input (fikovnik/-encode-key-mod key-code mod-code))
            (key (if (null key-emacs) 
                     (kbd (format "%s-%c" mod key-code))
                   key-emacs)))
       (when fikovnik/my-keys-debug
         (message "binding: %s to %s (%s-%c)" input key mod key-code))

       ;(define-key input-decode-map input key)
       (define-key xterm-function-map input key)))))

(when fikovnik/my-keys
  (message "Enabling my-keys")
  (eval-after-load "xterm" '(fikovnik/emacs-encode-keys)))
;;(unless (display-graphic-p)
;;  (fikovnik/emacs-encode-keys))
#+END_SRC

**** TODO should this go the the xterm-function-map instead?
- try it in GUI to see what works better
- try it in Xterm
- try term keys
** TODO input map in GUI
- sync it with terminal
** Variables

#+BEGIN_SRC emacs-lisp
(defvar fikovnik/backup-dir (expand-file-name "backups" user-emacs-directory)
  "backup directory")
(defvar fikovnik/savefile-dir (expand-file-name "savefile" user-emacs-directory)
  "backup directory")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(unless (file-exists-p fikovnik/savefile-dir)
  (make-directory fikovnik/savefile-dir))
#+END_SRC

** Customize file =custom.el=                                          :wip:

Set up the customize file to its own separate file, instead of saving
customize settings in [[file:init.el][init.el]].

*** TODO what to do with the custom file? Keep it, keep it, but not version it or send to /tmp

#+BEGIN_SRC emacs-lisp
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
(load custom-file)
#+END_SRC

** Set up =use-package=

These additional packages add the ability to diminish minor modes from
modeline, and to conveniently bind keys using =:diminish= and =:bind-key=
keywords in =(use-package)=.

#+BEGIN_SRC emacs-lisp
;; :diminish keyword
(use-package diminish :ensure t)

;; :bind keyword
(use-package bind-key :ensure t)
#+END_SRC

** Install hydra

#+BEGIN_SRC emacs-lisp
(use-package hydra :ensure t)
#+END_SRC

** Install smartrep                                           :experimental:

I would prefer to use hydra for all, but it somehow does not work with multiple
cursors.

#+BEGIN_SRC emacs-lisp
(use-package smartrep
  :ensure t
  :custom
  (smartrep-mode-line-string-activated "[SR]")
  ;; no modeline higlighting
  (smartrep-mode-line-active-bg (face-background 'mode-line))
)
#+END_SRC

* Defaults
** Enable some useful functions

These functions are useful so activate them.

#+BEGIN_SRC emacs-lisp
(put 'downcase-region 'disabled nil)
(put 'upcase-region 'disabled nil)
(put 'narrow-to-region 'disabled nil)
(put 'dired-find-alternate-file 'disabled nil)
#+END_SRC

** File backup                                                         :wip:
*** TODO better way to handle backups
*** TODO document how does it exactly work

#+BEGIN_SRC emacs-lisp
(setq
      auto-save-list-file-name           (concat user-emacs-directory "/autosave")
      backup-directory-alist            `((".*" . ,fikovnik/backup-dir))
      ;;auto-save-file-name-transforms    `((".*" ,(concat user-emacs-directory "/auto-save-list/") t))
      version-control                    t
      backup-by-copying                  t
      delete-old-versions                t
      kept-new-versions                  6
      kept-old-versions                  2
      history-length                     1000
      backup-inhibited                   nil
      make-backup-files                  t
      auto-save-default                  t
      create-lockfiles                   nil
)
#+END_SRC

** Auto save file buffers

Automatically save buffers associated with files on buffer switch
and on windows switch.

#+BEGIN_SRC emacs-lisp
(use-package super-save
  :ensure t
  :config
  ;; add integration with ace-window
  (add-to-list 'super-save-triggers 'ace-window)
  (super-save-mode +1))
#+END_SRC

** Use UTF-8

I guess all this is trying to say to use UTF-8 by default.

#+BEGIN_SRC emacs-lisp
(setq
      locale-coding-system          'utf-8
      default-process-coding-system '(utf-8-unix . utf-8-unix)
)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)
(set-language-environment 'utf-8)
(prefer-coding-system 'utf-8)
#+END_SRC

** Sensible defaults

Taken mostly from the [[https://github.com/hrs/sensible-defaults.el/blob/master/sensible-defaults.el][sensible-defaults.el]] and [[http://www.emacs-bootstrap.com/][emacs-bootstrap]].

*** Eval expression

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-:") 'eval-expression)
#+END_SRC

*** Yes/No confirmation

Answering just 'y' or 'n' will do

#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

*** Defaults

#+BEGIN_SRC emacs-lisp
(setq
      confirm-nonexistent-file-or-buffer  t
      ;; apropos searches more extensively
      apropos-do-all                      t
      ;; save existing clipboard into kill ring before replacing it
      save-interprogram-paste-before-kill t
      ;; when middle-clicking the mouse to yank from the clipboard, insert the text where point is, not where the mouse cursor is
      mouse-yank-at-point                 t
      require-final-newline               t
      visible-bell                        t
      ;; http://ergoemacs.org/emacs/emacs_stop_cursor_enter_prompt.html
      minibuffer-prompt-properties        '(read-only t point-entered minibuffer-avoid-prompt face minibuffer-prompt)
      ;; Disable non selected window highlight
      cursor-in-non-selected-windows      nil
      highlight-nonselected-windows       nil
      ;; PATH
      exec-path                           (append exec-path '("/usr/local/bin/"))
      ;; single space to indicate end of a sentance
      sentence-end-double-space           nil
      x-select-enable-clipboard           t
      ;; -i gets alias definitions from shell
      shell-command-switch                "-ic"
      echo-keystrokes                     0.1
      recentf-max-saved-items             100
      scroll-step                         1
      use-dialog-box                      nil
      kill-ring-max                       300
      initial-major-mode                  'text-mode
      cursor-in-non-selected-windows      t
      ;; when opening a file, follow symlinks
      vc-follow-symlinks                  t
      scroll-error-top-bottom             t
)

(setq-default
      tab-width                           2
      indent-tabs-mode                    nil
      ;; maximum line width
      fill-column                         79
      ;; don't fold lines
      truncate-lines                      t
      frame-title-format                  '("%b")
      indicate-empty-lines                t
      cursor-type                         'bar
      display-line-numbers-grow-only      t
      display-line-numbers-width-start    t
      show-paren-delay                    0.0
      imenu-auto-rescan                   t
)

(blink-cursor-mode -1)
(delete-selection-mode t)
(show-paren-mode t)
(column-number-mode t)
(global-visual-line-mode t)
(global-hl-line-mode t)
;; when something changes a file, automatically refresh the buffer containing
;; that file so they can't get out of sync.
(global-auto-revert-mode t)
(transient-mark-mode t)
(toggle-truncate-lines t)
(whitespace-mode -1)

(diminish 'visual-line-mode " ↩")

(add-hook 'prog-mode-hook #'display-line-numbers-mode)
(add-hook 'text-mode-hook #'display-line-numbers-mode)
#+END_SRC

*** Turn on syntax highlighting whenever possible

#+begin_src emacs-lisp
(global-font-lock-mode t)
#+end_src

*** When saving a file that starts with =#!=, make it executable

#+BEGIN_SRC emacs-lisp
(add-hook 'after-save-hook
          'executable-make-buffer-file-executable-if-script-p)
#+END_SRC

*** Popup window management

#+BEGIN_SRC emacs-lisp
(use-package popwin
  :ensure t
  :config
  (popwin-mode 1))
#+END_SRC

The package seems not to be maintained, an alternative might be [[https://github.com/wasamasa/shackle][shackle]].

*** Save placesss

This remembers your location in a file when saving files.

#+BEGIN_SRC emacs-lisp
(use-package saveplace
  :custom
  (save-place-file (expand-file-name "saveplace" fikovnik/savefile-dir)))

(save-place-mode 1)
#+END_SRC
*** Meaningful names for buffers with the same name

#+BEGIN_SRC emacs-lisp
(setq uniquify-buffer-name-style 'forward
      uniquify-separator "/"
      ;; rename after killing uniquified
      uniquify-after-kill-buffer-p t
      ;; don't muck with special buffers
      uniquify-ignore-buffers-re "^\\*")
#+END_SRC

*** Track history

#+BEGIN_SRC emacs-lisp
;; savehist keeps track of some history
(use-package savehist
  :custom
  ;; search entries
  (savehist-additional-variables '(search-ring regexp-search-ring))
  ;; save every minute
  (savehist-autosave-interval 60)
  ;; keep the home clean
  (savehist-file (expand-file-name "savehist" fikovnik/savefile-dir))
  :config
  (savehist-mode +1))
#+END_SRC

*** Recent files tracking
**** Functions

#+BEGIN_SRC emacs-lisp
(defun fikovnik/recentf-exclude-p (file)
  "A predicate to decide whether to exclude FILE from recentf."
  (let ((file-dir (file-truename (file-name-directory file))))
    (cl-some (lambda (dir)
               (string-prefix-p dir file-dir))
             (mapcar 'file-truename (list prelude-savefile-dir package-user-dir)))))
#+END_SRC

**** Configuration

#+BEGIN_SRC emacs-lisp
(use-package recentf
  :custom
  (recentf-save-file (expand-file-name "recentf" fikovnik/savefile-dir))
  (recentf-max-saved-items 500)
  (recentf-max-menu-items 15)
  ;; disable recentf-cleanup on Emacs start, because it can cause
  ;; problems with remote files
  (recentf-auto-cleanup 'never)
  :config
  ;; only trace real files
  (add-to-list 'recentf-exclude 'prelude-recentf-exclude-p)
  (recentf-mode +1))
#+END_SRC

* Editing
** Deleting spaces

| Key     | Description                                                | Function                 |
|---------+------------------------------------------------------------+--------------------------|
| =M-\=   | Delete all spaces and tabs around point                    | =delete-horizonal-space= |
| =M-SPC= | Delete all spaces and tabs around point, leaving one space | =just-one-space=         |

** Copy and paste
*** Functions

These functions allow to C&P to the system clipboard using either terminal
escape code or xsel command if running in GUI.

#+BEGIN_SRC emacs-lisp
(defun fikovnik/copy-to-xclipboard ()
  (interactive)
  (if (use-region-p)
      (if (not (display-graphic-p))
          (letrec ((s (buffer-substring-no-properties (region-beginning) (region-end)))
                   (s-length (+ (* (length s) 3) 2)))
            (if (<= s-length 16384) ; magic number set to the same as ESC_BUF_SIZ of suckless termial (st.c)
                (progn
                  (send-string-to-terminal (concat "\e]52;c;"
                                                   (base64-encode-string (encode-coding-string s 'utf-8) t)
                                                   "\07"))
                  (message "Yanked region to terminal clipboard")
                  (deactivate-mark))
              (message "Selection too long (%d) to send to terminal." s-length)))
        (if (= 0 (shell-command-on-region (region-beginning) (region-end) "xsel -i -b"))
            (message "Yanked region to X-clipboard")
          (error "Is program `xsel' installed?")))
    (message "Nothing to yank to terminal clipboard")))

(defun fikovnik/cut-to-xclipboard ()
  (interactive)
  (fikovnik/copy-to-xclipboard)
  (kill-region (region-beginning) (region-end)))

(defun fikovnik/paste-from-xclipboard ()
  "Uses shell command `xsel -o' to paste from x-clipboard. With
one prefix arg, pastes from X-PRIMARY, and with two prefix args,
pastes from X-SECONDARY."
  (interactive)
  (if (display-graphic-p)
      (clipboard-yank)
    (letrec
        ((opt (prefix-numeric-value current-prefix-arg))
         (opt (cond
               ((=  1 opt) "b")
               ((=  4 opt) "p")
               ((= 16 opt) "s"))))
(insert (shell-command-to-string (concat "xsel -o -" opt))))))
#+END_SRC

*** Bind keys

Bind =C-S-X= to cut and =C-X-C= to copy.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-S-X") 'fikovnik/cut-to-xclipboard)
(global-set-key (kbd "C-S-C") 'fikovnik/copy-to-xclipboard)
#+END_SRC

The paste shortcut (=C-S-V=) we only want in GUI. When running in terminal it
is better to use the terminal paste since it will be a [[https://cirw.in/blog/bracketed-paste][bracketed paste]].

#+BEGIN_SRC emacs-lisp
(when (display-graphic-p)
  (global-set-key (kbd "C-S-V") 'fikovnik/paste-from-xclipboard))
#+END_SRC

** Fill/unfill paragraph

#+BEGIN_SRC emacs-lisp
(use-package unfill
  :defer t
  :commands (unfill-region unfill-paragraph unfill-toggle)
  :bind
  ([remap fill-paragraph] . unfill-toggle))
#+END_SRC

** Multiple cursors

#+BEGIN_SRC emacs-lisp
(global-unset-key (kbd "M-m"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
  :ensure t
  :config
  (smartrep-define-key global-map "M-m"
    '(("n" . 'mc/mark-next-like-this)
      ("u" . 'mc/unmark-next-like-this)
      ("s" . 'mc/skip-to-next-like-this)
      ("N" . 'mc/mark-previous-like-this)
      ("U" . 'mc/unmark-previous-like-this)
      ("S" . 'mc/skip-to-previous-like-this)
      ;; TODO: this should be (er/mark-word) followed by (mc/hydra)
      ("m" . 'mc/mark-more-like-this-extended)
      ("a" . 'mc/mark-all-like-this)
      ("d" . 'mc/mark-all-like-this-dwim)
      ("r" . 'mc/reverse-regions))))
#+END_SRC

** Move lines up / down
*** TODO fix this in org-mode which takes over this binding

#+BEGIN_SRC emacs-lisp
(use-package move-dup
  :ensure t
  :defer t
  :bind
  ("M-<up>" . md-move-lines-up)
  ("M-<down>" . md-move-lines-down)
  ("M-S-<up>" . md-duplicate-up)
  ("M-S-<down>" . md-duplicate-down))
#+END_SRC

** Join lines

The =join-line= command (aliased to =delete-indentation=) works from the last
line to be joined upwards. I prefer the other way around (cf. [[https://emacsredux.com/blog/2013/05/30/joining-lines/][here]]).

#+BEGIN_SRC emacs-lisp
(defun fikovnik/join-line ()
  "Join the current line with the line beneath it."
  (interactive)
  (delete-indentation 1))
#+END_SRC

| Key   | Description                                       |
|-------+---------------------------------------------------|
| =M-j= | Join the current line with the line *beneath* it. |
| =M-J= | Join the current line with the line *over* it.    |

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-j") 'fikovnik/join-line)
(global-set-key (kbd "M-J") 'join-line)
#+END_SRC

** Open line above / bellow

| Key     | Description                                        |
|---------+----------------------------------------------------|
| =C-PEM= | To insert a blank line *above* the line you're on. |
| =C-EM=  | To insert a blank line *below* the line you're on. |

** Comment / un-comment lines
*** Functions
First, define a function taken from [[https://stackoverflow.com/a/11517584/219584][here]]:

#+BEGIN_SRC emacs-lisp
(defun fikovnik/comment-or-uncomment-line-or-region ()
  "Comments or uncomments the current line or region."
  (interactive)
  (if (region-active-p)
      (comment-or-uncomment-region (region-beginning) (region-end))
    (comment-or-uncomment-region (line-beginning-position) (line-end-position))))
#+END_SRC

*** Binding
**** TODO this does not work so far, because in the terminal =C-;= is seen as =;= only.

#+BEGIN_SRC emacs-lisp
(global-unset-key (kbd "C-;"))
(global-set-key (kbd "C-;") 'fikovnik/comment-or-uncomment-line-or-region)
#+END_SRC

** Whole line

The following [[https://emacs.stackexchange.com/questions/2347/kill-or-copy-current-line-with-minimal-keystrokes][snippet]] changes the behavior of:
- =C-w=: with no active region, kill a single line instead
- =M-w=: with no active region, copy a single line instead

#+BEGIN_SRC emacs-lisp
(defun fikovnik/slick-cut (beg end)
  (interactive
   (if mark-active
       (list (region-beginning) (region-end))
     (list (line-beginning-position) (line-beginning-position 2)))))

(advice-add 'kill-region :before #'fikovnik/slick-cut)

(defun fikovnik/slick-copy (beg end)
  (interactive
   (if mark-active
       (list (region-beginning) (region-end))
     (message "Copied line")
     (list (line-beginning-position) (line-beginning-position 2)))))

(advice-add 'kill-ring-save :before #'fikovnik/slick-copy)
#+END_SRC
** Expand region (=M-r=)

Define a function that simply selects the current line.

#+BEGIN_SRC emacs-lisp
(defun fikovnik/select-line ()
  "Select current line. If region is active, extend selection downward by line."
  (interactive)
  (if (region-active-p)
      (progn
        (forward-line 1)
        (end-of-line))
    (progn
      (end-of-line)
      (set-mark (line-beginning-position)))))
#+END_SRC

Define the =M-r= prefix and use it for expand region, including the line
selection defined above.

#+BEGIN_SRC emacs-lisp
(global-unset-key (kbd "M-r"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :ensure t
  :bind
  (("M-r m"  . er/expand-region)
   ("M-r ("  . er/mark-inside-pairs)
   ("M-r )"  . er/mark-outside-pairs)
   ("M-r '"  . er/mark-inside-quotes)
   ("M-r \"" . er/mark-outside-quotes) ; it's just a quotation mark
   ("M-r o" . er/mark-org-parent)
   ("M-r u" . er/mark-url)
   ("M-r b" . er/mark-org-code-block)
   ("M-r ." . er/mark-method-call)
   ("M-r >" . er/mark-next-accessor)
   ("M-r w" . er/mark-word)
   ("M-r d" . er/mark-defun)
   ("M-r e" . er/mark-email)
   ("M-r ," . er/mark-symbol)
   ("M-r <" . er/mark-symbol-with-prefix)
   ("M-r ;" . er/mark-comment)
   ("M-r s" . er/mark-sentence)
   ("M-r S" . er/mark-text-sentence)
   ("M-r p" . er/mark-paragraph)
   ("M-r P" . er/mark-text-paragraph)
   ("M-r l" . fikovnik/select-line)))
#+END_SRC

** Snippets
#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :ensure t
  :init
  (yas-global-mode 1))
#+end_src
** Auto completion

#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  :config
  (add-hook 'after-init-hook 'global-company-mode))
#+END_SRC
*** TODO configure backends
*** TODO [[https://github.com/expez/company-quickhelp][company-quick-help]]

** TODO delete syntax
** Spell checking
*** Configuration

Spell check using aspell.

#+BEGIN_SRC emacs-lisp
(use-package flyspell
  :custom
  (ispell-program-name "aspell")
  (ispell-extra-args '("--sug-mode=ultra")))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package flyspell-correct-helm
  :ensure t
  :defer t
  :bind ("C-M-;" . flyspell-correct-wrapper)
  :custom
  (flyspell-correct-interface #'flyspell-correct-helm))
#+END_SRC

** TODO surround
- https://github.com/ganmacs/emacs-surround
** Rainbow delimiters

#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :ensure t
  :defer t
  :hook
  (prog-mode . rainbow-delimiters-mode))
#+END_SRC

** TODO smartparens
** TODO zap to char
- M-z
- M-Z
** TODO indentation
* Movement and navigation
** Windows (=C-x w=)
*** Overview

| Key         | Description                          | Function      |
|-------------+--------------------------------------+---------------|
| =C-c left=  | Undo changes in window configuration | =winner-undo= |
| =C-c right= | Redo changes in window configuration | =winner-redo= |
| =C-x o=     | Select window using Avy              | =ace-window=  |

*** Selecting windows

**** Windmove

Windmove defines functions to easily select windows. We do not use the default
keybinding, instead it is bound by the =hydra-window=.

#+BEGIN_SRC emacs-lisp
(use-package windmove
  :ensure t
  :custom
  (windmove-wrap-around t)
  :config
  (windmove-default-keybindings)
  (add-hook 'org-shiftup-final-hook 'windmove-up)
  (add-hook 'org-shiftleft-final-hook 'windmove-left)
  (add-hook 'org-shiftdown-final-hook 'windmove-down)
  (add-hook 'org-shiftright-final-hook 'windmove-right))
#+END_SRC

**** Other window, previous on =C-,= and =C-.=

#+BEGIN_SRC emacs-lisp
(defun prev-window ()
  (interactive)
  (other-window -1))

(global-set-key (kbd "C-,") #'prev-window)
(global-set-key (kbd "C-.") #'other-window)
#+END_SRC

*** Save window layout stack using the =winner-mode=

This will allow to go back/fort between window layouts.

#+BEGIN_SRC emacs-lisp
(use-package winner
  :ensure t
  :config
  (winner-mode 1))
#+END_SRC

*** Jump between windows

Use [[https://github.com/abo-abo/ace-window][ace-window]] to quickly switch between windows using =C-x o= instead of the
default =other-window= command.

#+BEGIN_SRC emacs-lisp
(use-package ace-window
  :ensure t
  :defer t
  :custom
  (aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
  (aw-dispatch-always nil)
  (aw-dispatch-alist
   '((?x aw-delete-window     "Delete Window")
	   (?S aw-swap-window       "Swap Windows")
	   (?m aw-maximize-window   "Maximize Window")
     (?M aw-move-window       "Move Window")
	   (?c aw-copy-window       "Copy Window")
	   (?= aw-split-window-fair "Split Fair Window")
	   (?- aw-split-window-vert "Split Vert Window")
	   (?| aw-split-window-horz "Split Horz Window")
	   (?? aw-show-dispatch-help)))
  :config
  (set-face-attribute 'aw-leading-char-face nil :weight 'bold)
  :bind
  ("C-x o" . ace-window))
#+END_SRC

*** Setup =C-x w= micro state                                       :hydra:
**** Functions
Define a function to [[https://gist.github.com/3402786][maximize window]].

#+BEGIN_SRC emacs-lisp
(defun fikovnik/maximize-window ()
  (interactive)
  (if (and (= 1 (length (window-list)))
           (assoc ?_ register-alist))
      (jump-to-register ?_)
    (progn
      (window-configuration-to-register ?_)
      (delete-other-windows))))
#+END_SRC

**** Hydra

#+BEGIN_SRC emacs-lisp
(defhydra hydra-window (:hint nil)
   "
   ^Select^    ^Split^           ^Switch^           ^Resize^      ^Misc^
  -----------------------------------------------------------------------
      _↑_      _-_: vertical     _b_uffer             ⇧         _u_ndo/_r_edo
    _←_   _→_    _|_: horizontal   _f_ind files       ⇦   ⇨       _a_ce-window
      _↓_      ^ ^               _s_wap               ⇩         _d_elete/ace-_D_elete
   ^ ^         ^ ^               _m_aximize/_B_alance
"
   ("<left>" windmove-left)
   ("<down>" windmove-down)
   ("<up>" windmove-up)
   ("<right>" windmove-right)
   ("S-<left>" shrink-window-horizontally)
   ("S-<down>" enlarge-window)
   ("S-<up>" shrink-window)
   ("S-<right>" enlarge-window-horizontally)
   ("b" helm-mini :color blue)
   ("f" helm-find-files :color blue)
   ("a" ace-window :color blue)
   ("|" (lambda ()
          (interactive)
          (split-window-right)
          (windmove-right)))
   ("-" (lambda ()
          (interactive)
          (split-window-below)
          (windmove-down)))
   ("s" (lambda ()
          (interactive)
          (ace-window 4)
          (add-hook 'ace-window-end-once-hook
                    'hydra-window/body)))
   ("d" kill-buffer-and-window :color blue)
   ("D" ace-delete-window)
   ("m" fikovnik/maximize-window :color blue)
   ("B" balance-windows-area)
   ("u" (progn
          (winner-undo)
          (setq this-command 'winner-undo)))
   ("r" winner-redo)
   ("q" nil :color blue))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x w") 'hydra-window/body)
#+END_SRC
** Go to (=M-q=)
*** Setup Avy

This allows to quickly jump around in the buffer. The way it is setup is by
remapping the =M-g= to a hydra that calls various [[https://github.com/abo-abo/avy][avy]] functions.

#+BEGIN_SRC emacs-lisp
(global-unset-key (kbd "M-g"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package avy
  :ensure t
  :bind
  ("M-g" . hydra-avy/body)
  :config
  (avy-setup-default)
  (set-face-attribute 'avy-lead-face-0 nil :foreground "black"))
#+END_SRC

*** Setup =M-g= micro state                                         :hydra:

#+BEGIN_SRC emacs-lisp
(defhydra hydra-goto (:exit t :hint nil :color blue)
  "
   ^Line^   ^Region^   ^Goto^
  ----------------------------------------------------------
   _y_ank   _Y_ank     timed _c_har  _C_har
   _m_ove   _M_ove     _w_ord        any _W_ord
   _k_ill   _K_ill     _l_ine        end of _L_ine  _g_: line number"
  ("g" goto-line)
  ("c" avy-goto-char-timer)
  ("C" avy-goto-char)
  ("w" avy-goto-word-1)
  ("W" avy-goto-word-0)
  ("l" avy-goto-line)
  ("L" avy-goto-end-of-line)
  ("m" avy-move-line)
  ("M" avy-move-region)
  ("k" avy-kill-whole-line)
  ("K" avy-kill-region)
  ("y" avy-copy-line)
  ("Y" avy-copy-region)
  ("q" nil))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-g") 'hydra-goto/body)
#+END_SRC

*** TODO next error / previous error

** Buffers (=C-x b=)
*** Functions

#+BEGIN_SRC emacs-lisp
(defun fikovnik/new-empty-buffer ()
  "Create a new buffer called untitled(<n>)."
  (interactive)
  (let ((newbuf (generate-new-buffer "untitled")))
    (with-current-buffer newbuf
      (setq-local buffer-offer-save t))
    (switch-to-buffer newbuf nil 'force-same-window)))
#+END_SRC

*** Setup =C-x b= micro state                                       :hydra:
**** TODO switch to messages buffer
**** TODO switch to scratch buffer

#+BEGIN_SRC emacs-lisp
(defhydra hydra-buffers (:exit t :hint nil)
("b" helm-mini "list")
("n" next-buffer "next")
("p" previous-buffer "previous")
("k" kill-this-buffer "kill")
("x" kill-buffer-and-window "close")
("R" revert-buffer "revert")
("N" fikovnik/new-empty-buffer "new")
("i" ibuffer "ibuffer")
)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x b") 'hydra-buffers/body)
#+END_SRC
*** Binding

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x C-k") 'kill-this-buffer)
#+END_SRC

** TODO pgup/pgdown go to the same location
** TODO Go to matching paren
** TODO Gentle navigation
** TODO highlight symbols (=*=, =#=)
- https://github.com/nschum/highlight-symbol.el
** TODO move to previous/next edit location
** TODO ace-link
- https://github.com/abo-abo/ace-link
** =C-a= / =home= and =C-e= / =end= keys move to the beginning/end of the line smartly

#+BEGIN_SRC emacs-lisp
(use-package mwim
  :ensure t
  :defer t
  :bind
  ("C-a" . mwim-beginning)
  ("C-e" . mwim-end)
  ("<home>" . mwim-beginning)
  ("<end>" . mwim-end))
#+END_SRC
** Imenu

#+BEGIN_SRC emacs-lisp
(use-package imenu-anywhere
  :ensure t
  :defer t
  :bind
  ("M-i" . 'imenu-anywhere))
#+END_SRC

** Helm
*** Functions

#+BEGIN_SRC emacs-lisp
(defun fikovnik/helm-hide-minibuffer-maybe ()
  "Hide minibuffer in Helm session if we use the header line as input field."
  (when (with-helm-buffer helm-echo-input-in-header-line)
    (let ((ov (make-overlay (point-min) (point-max) nil nil t)))
      (overlay-put ov 'window (selected-window))
      (overlay-put ov 'face
                   (let ((bg-color (face-background 'default nil)))
                     `(:background ,bg-color :foreground ,bg-color)))
      (setq-local cursor-type nil))))
#+END_SRC

*** Basics

#+BEGIN_SRC emacs-lisp
(use-package helm
  :ensure t
  :custom
  (helm-echo-input-in-header-line        t)
  (helm-ff-file-name-history-use-recentf t)
  (helm-ff-skip-boring-files             t)
  (helm-M-x-fuzzy-match                  t)
  (helm-buffers-fuzzy-matching           t)
  (helm-recentf-fuzzy-match              t)
  (helm-split-window-in-side-p           t)
  (helm-split-window-default-side        'below)
  (helm-move-to-line-cycle-in-source     t)
  (helm-idle-delay                       0.0)
  (helm-input-idle-delay                 0.01)
  (helm-quick-update                     t)
  (helm-autoresize-max-height            0)
  (helm-autoresize-min-height            20)
  :config
  (helm-autoresize-mode 1)
  (helm-mode 1)
  (add-hook 'helm-minibuffer-set-up-hook #'fikovnik/helm-hide-minibuffer-maybe)
  :bind
  (("M-x" . helm-M-x)
  ("C-x C-f" . helm-find-files)
  ("C-x c o" . helm-occur)
  ("C-x c k" . helm-show-kill-ring)
  ("M-y" . helm-show-kill-ring)
  :map helm-map
  ("<tab>" . helm-execute-persistent-action) ; rebind tab to do persistent action
  ("C-i" . helm-execute-persistent-action) ; make TAB works in terminal
  ("C-z" . helm-select-action) ; list actions using C-z
  ))
#+END_SRC

*** Searching with =helm-ag=

#+BEGIN_SRC emacs-lisp
(use-package helm-ag
  :ensure t
  :custom
  (helm-ag-base-command "rg --no-heading"))
#+END_SRC

*** Project files with =helm-ls-git=
**** TODO how is this connected to [[https://github.com/bbatsov/helm-projectile][helm-projectile]]?

#+BEGIN_SRC emacs-lisp
(use-package helm-ls-git
  :ensure t
  :defer t
  :bind
  ("C-x p f" . helm-browse-project))
#+END_SRC
*** Describe bindings

#+BEGIN_SRC emacs-lisp
(use-package helm-descbinds
  :ensure t
  :defer t
  :bind
  ([remap describe-bindings] . helm-descbinds))
#+END_SRC

*** Other
**** TODO helm-dictionary
**** TODO helm-addressbook / helm-mu
**** TODO helm-c-yasnippet
**** TODO imenu-anywhere
**** TODO helm-bibtex
**** TODO helm-dash
**** helm-xref

#+BEGIN_SRC emacs-lisp
(use-package helm-xref
  :ensure t
  :defer t
  :commands helm-xref-show-xrefs
  :custom
  (xref-show-xrefs-function 'helm-xref-show-xrefs))
#+END_SRC

**** TODO swiper-helm
**** TODO [[https://github.com/ShingoFukuyama/helm-swoop][helm-swoop]]
**** helm-rg
#+BEGIN_SRC emacs-lisp
(use-package helm-rg
  :ensure t
  :defer t
  :bind
  ("C-x p /" . helm-projectile-rg)
  ("C-S-s" . helm-rg))
#+END_SRC
**** helm-projectile

#+BEGIN_SRC emacs-lisp
(use-package helm-projectile
  :ensure t
  :defer t
  :bind
("C-x p h" . helm-projectile)
("C-x p p" . helm-projectile-switch-project)
("C-x p f" . helm-projectile-find-file)
("C-x p F" . helm-projectile-find-file-in-known-projects)
("C-x p r" . helm-projectile-recentf)
("C-x p a" . helm-projectile-find-other-file))
#+END_SRC

**** TODO https://github.com/ganmacs/emacs-surround
** TODO text objects
- https://github.com/clemera/objed
** TODO isearch
- a keymap with all the options
** Bookmarks

| Key       | Description        | Function         |
|-----------+--------------------+------------------|
| =C-x r l= | List bookmarks     | =helm-bookmarks= |
| =C-x r b= | Jump to a bookmark | =bookmark-jump=  |
| =C-x r m= | Set bookmark       | =bookmark-set=   |

#+BEGIN_SRC emacs-lisp
(use-package bookmark
  :custom
  (bookmark-default-file (expand-file-name "bookmarks" fikovnik/savefile-dir))
  (bookmark-save-flag 1))
#+END_SRC

* Search and replace
** TODO search using swoop
- https://github.com/ShingoFukuyama/helm-swoop
** TODO replace
- is the visual regexp good enough?
* Toggles (=C-x t=)
** Setup =C-x t= micro state                                         :hydra:

#+BEGIN_SRC emacs-lisp
(defhydra hydra-toggle (:color blue :hint nil)
  "
[_a_] abbrev-mode:       %`abbrev-mode
[_d_] debug-on-error:    %`debug-on-error
[_f_] auto-fill-mode:    %`auto-fill-function
[_t_] truncate-lines:    %`truncate-lines
[_w_] whitespace-mode:   %`whitespace-mode
[_l_] org link display:  %`org-descriptive-links
"
  ("a" abbrev-mode)
  ("d" toggle-debug-on-error)
  ("f" auto-fill-mode)
  ("t" toggle-truncate-lines)
  ("w" whitespace-mode)
  ("l" org-toggle-link-display)
  ("q" nil "quit"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x t") 'hydra-toggle/body)
#+END_SRC
* TODO Mouse
* Projects
** Configuration

#+BEGIN_SRC emacs-lisp
(use-package projectile
  :ensure t
  :custom
  (projectile-indexing-method 'alien)
  (projectile-completion-system 'helm)
  (projectile-switch-project-action 'helm-projectile)
  :config
  (projectile-global-mode)
  (helm-projectile-on))
#+END_SRC

* Packages
** iqa - quick access to config file

#+BEGIN_SRC emacs-lisp
(use-package iqa
  :ensure t
  :custom
  (iqa-user-init-file (concat user-emacs-directory "config.org"))
  :config
  (iqa-setup-default))
#+END_SRC

** ibuffers

#+BEGIN_SRC emacs-lisp
(use-package ibuffer
  :bind
  ([remap list-buffers] . ibuffer))
#+END_SRC

**** TODO hydra
- https://github.com/abo-abo/hydra#the-impressive-looking-one
** which-key

#+BEGIN_SRC emacs-lisp
(use-package which-key
  :diminish which-key-mode
  :custom
  (which-key-idle-delay 0.3)
  :config
  (which-key-mode))
#+END_SRC

** dired
*** Settings

Auto refresh dired
#+BEGIN_SRC emacs-lisp
(add-hook 'dired-mode-hook 'auto-revert-mode)
(setq
      global-auto-revert-non-file-buffers t
      auto-revert-verbose                 nil
      ;; file sizes in human-readable units (KB, MB, etc)
      dired-listing-switches              "-alh"
)
#+END_SRC

*** TODO hydra
** info
*** TODO hydra
** diff

#+BEGIN_SRC emacs-lisp
(use-package ediff
  :config
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
  (setq-default ediff-highlight-all-diffs 'nil)
  (setq ediff-diff-options "-w"))
#+END_SRC
** TODO kbd macros
* Version control
** Sort buffers in ibuffer based on git

#+BEGIN_SRC emacs-lisp
(use-package ibuffer-vc
  :ensure t)
#+END_SRC

** Magit

#+BEGIN_SRC emacs-lisp
(use-package magit
  :defer t
  :ensure t
  :custom
  (magit-display-buffer-function 'magit-display-buffer-fullframe-status-v1 "Enable fullscreen")
  :bind
  ("C-x g" . magit-status)
  ("C-x M-g" . fikovnik/dotfiles-magit))

(use-package magit-popup
  :ensure t)
#+END_SRC

** Highlight chnages in files

#+BEGIN_SRC emacs-lisp
(use-package diff-hl
  :ensure t
  :hook
  ((prog-mode . diff-hl-mode)
   (prog-mode . diff-hl-margin-mode)
   (org-mode . diff-hl-mode)
   (org-mode . diff-hl-margin-mode)
   (dired-mode . diff-hl-dired-mode))
  :config
  (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh))
#+END_SRC

** Support for my local dot-file config

I use git to version my dot files. While there are many options for managing
them such as [[https://github.com/RichiH/vcsh][vcsh]], I prefer the simplest possible, just using git and nothing
else. The trick is to separate work tree and git directory. While this work
well, magit does not understand this and has to have the relevant =--work-tree=
and =--git-dir= options explicitly set. For this I define a new function
=fikovnik/dotfiles-magit= which tries to do that.

#+BEGIN_SRC emacs-lisp
(defconst fikovnik/dotfiles-git-dir (expand-file-name "~/.dotfiles"))

(defun fikovnik/-dotfiles-remove-magit-config (&optional kill)
  (setq magit-git-global-arguments
        (remove (format "--work-tree=%s" (getenv "HOME")) magit-git-global-arguments))
  (setq magit-git-global-arguments
        (remove (format "--git-dir=%s" fikovnik/dotfiles-git-dir) magit-git-global-arguments))
  (advice-remove 'magit-mode-bury-buffer #'fikovnik/-dotfiles-remove-magit-config))

(defun fikovnik/dotfiles-magit ()
  (interactive)
  (when (and (boundp 'magit-git-global-arguments)
             (file-exists-p fikovnik/dotfiles-git-dir))
    (let ((home (getenv "HOME")))
      (add-to-list 'magit-git-global-arguments
                   (format "--work-tree=%s" home))
      (add-to-list 'magit-git-global-arguments
                   (format "--git-dir=%s" fikovnik/dotfiles-git-dir))
      (advice-add 'magit-mode-bury-buffer :after #'fikovnik/-dotfiles-remove-magit-config)
      (magit-status-setup-buffer home))))
#+END_SRC
*** TODO allow the =dotfiles-magit= work even if magit have not been initialized yet

* Org
** Default setup

#+BEGIN_SRC emacs-lisp
(use-package org
  :defer t
  ;; to be sure we have the latest Org version
  :ensure org-plus-contrib
  :mode
  ("\\.org$" . org-mode)
  :hook
  (org-mode . flyspell-mode)
  :custom
  (org-src-tab-acts-natively t)
  (org-src-preserve-indentation t)
  (org-confirm-babel-evaluate nil)
  (org-log-done t)
  (org-startup-with-inline-images t)
  (org-latex-prefer-user-labels t)
  (org-image-actual-width nil)
  (org-id-link-to-org-use-id 'create-if-interactive)
  (org-agenda-files '("~/Notes/Journal"))
  (org-directory "~/Notes")
  (org-default-notes-file "~/Notes/Journal/Notes.org")
  (org-startup-indented 1)
  (org-blank-before-new-entry '(((heading .  t) (plain-list-item . t))))
  (org-log-reschedule 'time)
  (org-log-into-drawer t)
  (org-refile-targets (quote ((nil :maxlevel . 9) (org-agenda-files :maxlevel . 9))))
  (org-refile-allow-creating-parent-nodes t)
  (org-refile-use-outline-path t)
  (org-src-fontify-natively t)
  (org-imenu-depth 8)
  (org-todo-keywords '((sequence "TODO(t)" "WAIT(w@/!)" "|" "DONE(d!)" "CANCELED(c@)")))
  (org-capture-templates
     '(("t" "Todo"         entry (file+headline "~/Notes/Journal/TODO.org" "INBOX")  "* TODO %?\ncaptured on: %U\nfrom: %a\n%i")
       ("n" "Note"         entry (file+headline "~/Notes/Journal/Notes.org" "Notes") "* %?\ncaptured on: %U\nfrom: %a\n%i")
       ("j" "Journal"      entry (file+datetree "~/Notes/Journal/Journal.org")    "* %?\n%i")
       ("J" "Work Journal" entry (file+datetree "~/Notes/Journal/Work.org")  "* %?\n%i")))
  :bind
  ("C-c c" . org-capture))
#+END_SRC

** Better appearance

#+BEGIN_SRC emacs-lisp
(use-package org-bullets
  :ensure t
  :custom
  (org-bullets-bullet-list '("•"))
  (org-ellipsis "↴")
  :hook
  (org-mode . org-bullets-mode))
#+END_SRC

** Yasnippet support

From [[https://orgmode.org/worg/org-faq.html#YASnippet][org-manual]]:
#+begin_quote
The way Org-mode binds the TAB key (binding to [tab] instead of \t) overrules yasnippets' access to this key.
#+end_quote

The following is the _official_ way to fix it:

#+BEGIN_SRC emacs-lisp
(defun yas/org-very-safe-expand ()
  (let ((yas/fallback-behavior 'return-nil)) (yas/expand)))

(add-hook 'org-mode-hook
          (lambda ()
            (make-variable-buffer-local 'yas/trigger-key)
            (setq yas/trigger-key [tab])
            (add-to-list 'org-tab-first-hook 'yas/org-very-safe-expand)
            (define-key yas/keymap [tab] 'yas/next-field)))
#+END_SRC
** Babel

#+BEGIN_SRC emacs-lisp
(use-package ob
  ;; it is a part of org-plus-contrib
  :ensure nil
  :defer t
  :commands org-babel-load-languages
  :custom
  (org-babel-load-languages
   '((shell . t)
     (emacs-lisp . t)))
  :init
  (progn
    (defun fikovnik/-org-babel-do-load-languages ()
      "Load all the languages declared in `org-babel-load-languages'."
      (org-babel-do-load-languages 'org-babel-load-languages
                                   org-babel-load-languages))
    (add-hook 'org-mode-hook 'fikovnik/-org-babel-do-load-languages)))
#+END_SRC

*** TODO Fix redisplay of inline images after a code block evaluation.

#+BEGIN_SRC emacs-lisp :tangle no
(add-hook 'org-babel-after-execute-hook 'spacemacs/ob-fix-inline-images)
#+END_SRC
** TODO org-ref
** TODO images
- https://github.com/abo-abo/org-download
** TODO [[https://github.com/alphapapa/helm-org-rifle][helm-org-rifle]]
** TODO [[https://github.com/alphapapa/org-sticky-header][org-sticky-header]]
** TODO [[https://github.com/bastibe/org-journal][org-journal]]
** TODO org-projectile
** TODO org-present ?
** TODO better refiling
* Languages
** General
*** Enable [[https://github.com/flycheck/flycheck][flycheck]]

#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :ensure t
  :init (global-flycheck-mode))
#+END_SRC

*** Enable LSP

#+BEGIN_SRC emacs-lisp
(use-package lsp-mode
  :ensure t
  :defer t
  :custom
  (lsp-prefer-flymake nil)
  :commands lsp)

(use-package lsp-ui
  :ensure t
  :defer t
  :commands lsp-ui-mode)

(use-package company-lsp
  :ensure t
  :defer t
  :custom
  (company-transformers nil)
  (company-lsp-async t)
  (company-lsp-cache-candidates nil)
  :commands company-lsp)
#+END_SRC

| Key     | Description      | Function                |
|---------+------------------+-------------------------|
| =M-.=   | Find definitions | =xref-find-definitions= |
| =M-?=   | Find references  | =xref-find-references=  |
| =C-M-.= |                  | =xref-find-apropos=     |

*** TODO enable [[https://github.com/emacs-lsp/dap-mode][dap]]
** C/C++
*** Backend

Use [[https://github.com/MaskRay/ccls/wiki/lsp-mode][ccls]] as the backend for C/C++.

#+BEGIN_SRC emacs-lisp
(use-package ccls
  :ensure t
  :defer t
  :custom
  (ccls-initialization-options '(:index (:comments 2) :completion (:detailedLabel t)))
  ;; no semantic highlighting
  (ccls-sem-highlight-method nil)
  :config
  (setq-default flycheck-disabled-checkers '(c/c++-clang c/c++-cppcheck c/c++-gcc))
  :hook
  ((c-mode c++-mode objc-mode) . (lambda () (require 'ccls) (lsp))))
#+END_SRC

Not sure why it is needed, but without I get =lsp--location-to-td-position:
Wrong type argument: hash-table-p, nil=, cf. [[https://github.com/MaskRay/emacs-ccls/issues/17][emacs-ccls:#17]]

#+BEGIN_SRC emacs-lisp
(setq xref-prompt-for-identifier
      '(not xref-find-definitions
            xref-find-definitions-other-window
            xref-find-definitions-other-frame
            xref-find-references))
#+END_SRC

*** TODO Semantic movement

Bind these to some keys?

#+BEGIN_SRC emacs-lisp :tangle no
(ccls-navigate "D") ;; roughly sp-down-sexp
(ccls-navigate "L")
(ccls-navigate "R")
(ccls-navigate "U")
#+END_SRC

*** TODO C++ hierarchy
ccls-member-hierarchy $ccls/member hierarchy:true

(ccls-call-hierarchy nil) ; caller hierarchy
(ccls-call-hierarchy t) ; callee hierarchy

$ccls/call

(ccls-inheritance-hierarchy nil) ; base hierarchy
(ccls-inheritance-hierarchy t) ; derived hierarchy

** TODO scala
- just code highlighting
** TODO R
- ESS or lsp
* Applications
** TODO agenda / calendar
** TODO email
** TODO elfeed
- https://github.com/abo-abo/elfeed
* Appearance
** Theme

#+BEGIN_SRC emacs-lisp
(use-package base16-theme
  :ensure t
  :config
  (load-theme 'base16-oceanicnext t))
#+END_SRC

*** TODO better contrast between hl-line and region
** Font

TODO: font size hydra

#+BEGIN_SRC emacs-lisp
(add-to-list 'default-frame-alist
  (cond
    ((string-equal system-type "darwin")    '(font . "dejavu sans mono"))
    ((string-equal system-type "gnu/linux") '(font . "dejavu sans mono"))))
#+END_SRC

** Modeline
*** TODO better modeline?
- if so look at [[https://github.com/seagle0128/doom-modeline][doom-modeline]]
#+BEGIN_SRC emacs-lisp :tangle no
(use-package doom-modeline
  :ensure t
  :config
  (add-hook 'after-init-hook #'doom-modeline-init)
  :custom
  (doom-modeline-major-mode-icon t)
  (doom-modeline-buffer-file-name-style 'buffer-name)
  (doom-modeline-icon t))
#+END_SRC
** Cursor
*** TODO bar cursor
*** TODO pink cursor
** Colors
*** TODO better TODO colors
* Troubleshooting
** Invalid function: =org-preserve-local-variables=

As indicated in [[https://github.com/syl20bnr/spacemacs/issues/11801#issuecomment-451755821][spacemacs/11801]], the problem is in version misalignment which
can be fixed by removing all =org-*/*.elc= files and compiling it again:

#+BEGIN_SRC sh :tangle no
find ~/.emacs.d/elpa/org*/*.elc -print0 | xargs -0 rm
#+END_SRC

And then running the following function

#+BEGIN_SRC emacs-lisp :results no
(defun fikovnik/recompile-elpa ()
  "Recompile packages in elpa directory"
  (interactive)
  (byte-recompile-directory package-user-dir 0 nil))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
(fikovnik/recompile-elpa)
#+END_SRC

** Unable to install a package

In the case a package installation from =(use-package)= fails due to a missing
file on MELPA, it might be due to an outdated local index. Use:

#+BEGIN_SRC emacs-lisp :tangle no
(package-refresh-contents)
#+END_SRC
