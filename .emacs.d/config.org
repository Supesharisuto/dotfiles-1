#+TITLE: Emacs configuration file
#+AUTHOR: Filip Krikava
#+PROPERTY: header-args :comments link :results silent :eval yes

* Overview
** Requirements
- fzf
- rg
- fd
** TODO describe the idea behind this configuration
** Key bindings
*** Emacs conventions

Emacs defines a a few [[https://www.gnu.org/software/emacs/manual/html%5Fnode/elisp/Key-Binding-Conventions.html][key binding conversions]]:
- =C-x= sequences are for Emacs commands
- =C-c C-key= sequences are for major modes
- =C-c {,},<,>,:,;= sequences are for major modes
- =C-c key= and =<F5>-<F9>= are for users
- =C-c <ASCII punctuations / symbols>= sequences are for minor modes
- Don't bind =C-h= following any prefix character (including =C-c=)
- Don't bind a key sequence ending in =<ESC>= except following another =<ESC>=
- Don't bind a key sequence ending in =C-g=

*** Overview of the main key bindings

| Key       | Micro state                            |
|-----------+----------------------------------------|
| =C-c w=   | Windows prefix                         |
| =C-c b=   | Buffers prefix                         |
| =C-c t=   | Toggles prefix                         |
| =C-c p=   | Projects prefix                        |
| =C-c S=   | Snippets prefix                        |
| =C-c e=   | Emacs configuration prefix             |
| =C-c c=   | Org capture                            |
| =C-c g=   | Magit prefix                           |
| =M-g=     | Go to prefix                           |
| =C-==     | Expand region prefix                   |
| =C-c /=   | Search in project or current directory |
| =M-'=     | Correct word                           |
| =M-;=     | Comment or uncomment                   |
| =M-i=     | imenu                                  |
| =M-I=     | imenu anywhere                         |
| =C-x C-k= | Kill buffer and its window             |
| =C-x C-b= | Switch buffer                          |
| =C-x o=   | Switch window                          |
| =M-*=     | Highlight symbol                       |
| =C-x f=   | Find file using fzf                    |
|           |                                        |

** TODO rename variables and functions (fikovnik -> my-)
** Remove the =init.el= from index tracking

#+BEGIN_SRC sh :tangle no
config update-index --assume-unchanged ~/.emacs.d/init.el
#+END_SRC
** Show matching function
https://with-emacs.com/posts/editing/show-matching-lines-when-parentheses-go-off-screen/
* Sources
** TODO clean and describe
- [[https://github.com/hlissner/doom-emacs/blob/develop/][Doom Emacs]]
- https://github.com/dakra/dmacs/blob/master/init.org
  - [[https://github.com/dakra/dmacs/blob/master/init.org#dired][dired]]
  - [[https://github.com/dakra/dmacs/blob/master/init.org#email][email]]
- [[https://github.com/jwiegley/dot-emacs/blob/master/init.el][John Wiegley’s config -- use-package author]]
- [[https://github.com/seagle0128/.emacs.d][Centaur emacs]]
  - look into https://github.com/seagle0128/.emacs.d/blob/master/lisp/init-basic.el
- [[https://ensime.github.io/editors/emacs/hacks/][Emacs hacks from Ensime folks]]
  - Coding in Lisp and Scala
- [[https://github.com/technomancy/better-defaults/blob/master/better-defaults.el][better-defaults.el]]
- [[http://www.emacs-bootstrap.com/][Emacs Bootstrap]]
- https://github.com/a13/emacs.d/blob/master/README.org
- https://github.com/freetonik/emacs-dotfiles/blob/master/init.org
  - emacs podcast guy configuration
- http://pages.sachachua.com/.emacs.d/Sacha.html
  - the emacs girl configuration
- https://github.com/danielmai/.emacs.d/blob/master/config.org
- https://thb.lt/emacs-cheatsheet/
- https://github.com/abo-abo/awesome-emacs
- https://github.com/redguardtoo/emacs.d
- https://github.com/abo-abo/oremacs
- https://github.com/purcell/emacs.d
- https://github.com/trending/emacs-lisp?since=monthly
- https://melpa.org/#/?sort=downloads&asc=false
- https://github.com/sam217pa/emacs-config/blob/develop/init.el
- https://sam217pa.github.io/2016/10/18/context-dependent-keybindings/
- http://www.matskjesrud.com/emacs.html
- https://old.reddit.com/r/emacs/comments/bk9k7l/tips_and_tricks_for_r_programming_in_academia/
  - about R
- http://juanjose.garciaripoll.com/blog/emacs-wanderlust-email
  - about wunderlust
[[https://github.com/jwiegley/use-package][use-package]]
** To check
https://github.com/milkypostman/powerline
https://github.com/Fuco1/smartparens

* Preamble
** Lexical scoping

I like lexical scoping.

#+BEGIN_SRC emacs-lisp
;;; -*- lexical-binding: t -*-
#+END_SRC

** Time the initialization

This will time immediate initialization to play the _under a second startup_
game. Not that it would really matter since I have instance of Emacs being
launched by systemd.

#+BEGIN_SRC emacs-lisp
(defconst emacs-start-time (current-time))
#+END_SRC

This const will be used in [[Restore startup optimizations]].

* Startup
** Speed up startup

A few _optimization_ for a faster startup and perhaps a snappier behavior based
on [[https://github.com/jwiegley/dot-emacs/blob/master/init.el#L7][John Wiegley’s config]] and [[https://github.com/hlissner/doom-emacs/blob/develop/early-init.el][Doom Emacs's early-init.el]].

*** Set GC normal and deferred limits

#+BEGIN_SRC emacs-lisp
(defvar my-gc-cons-threshold (* 16 1024 1024)
  "The default value to use for `gc-cons-threshold'. If you experience freezing,
decrease this. If you experience stuttering, increase this.")

(defvar my-gc-cons-upper-limit (* 512 1024 1024)
  "The temporary value for `gc-cons-threshold' to defer it.")
#+END_SRC

*** Defer garbage collection further back in the startup process

Allow more memory between GC cycle (default is 780kB) at startup.

#+BEGIN_SRC emacs-lisp
(setq gc-cons-threshold my-gc-cons-upper-limit)
#+END_SRC

*** Do not immediately load packages

Package initialize occurs automatically, before `user-init-file' is
loaded, but after `early-init-file'. Doom handles package
initialization, so we must prevent Emacs from doing it early!

#+BEGIN_SRC emacs-lisp
(setq package-enable-at-startup nil)
#+END_SRC

*** Prevent the glimpse of un-styled Emacs by setting these early

#+BEGIN_SRC emacs-lisp
(if (fboundp 'menu-bar-mode)
    (menu-bar-mode -1))
(if (fboundp 'tool-bar-mode)
    (tool-bar-mode -1))
(if (fboundp 'scroll-bar-mode)
    (scroll-bar-mode -1))
(if (fboundp 'horizontal-scroll-bar-mode)
    (horizontal-scroll-bar-mode -1))
#+END_SRC

*** Do not run site file

One less file to load at startup

#+BEGIN_SRC emacs-lisp
(setq site-run-file nil)
#+END_SRC

*** Temporarily disable file name handlers

The =filen-name-handler-alist= is consulted on every `require', `load' and
various path/io functions. One might get a minor speed up by nooping this.

#+BEGIN_SRC emacs-lisp
(defvar my--file-name-handler-alist file-name-handler-alist)
(setq file-name-handler-alist nil)
#+END_SRC

*** Longer message log

#+BEGIN_SRC emacs-lisp
(setq message-log-max 16384)
#+END_SRC

*** Restore startup optimizations

Finally, we need to restore the startup optimizations to their defaults in
order to prevent stuttering/freezes.

#+BEGIN_SRC emacs-lisp
(defun my--restore-startup-optimizations ()
  "Resets garbage collection settings to reasonable defaults (a large
`gc-cons-threshold' can cause random freezes otherwise) and resets
`file-name-handler-alist'."

  (setq file-name-handler-alist my--file-name-handler-alist)

  ;; Do this on idle timer to defer a possible GC pause that could result; also
  ;; allows deferred packages to take advantage of these optimizations.
  (run-with-idle-timer
   3 nil
   (lambda ()
     (setq-default gc-cons-threshold my-gc-cons-threshold)

     ;; To speed up minibuffer commands (like helm and ivy), we defer garbage
     ;; collection while the minibuffer is active.
     (defun my--defer-garbage-collection ()
       (setq gc-cons-threshold my-gc-cons-upper-limit))
     (defun my--restore-garbage-collection ()
       ;; Defer it so that commands launched from the minibuffer can enjoy the
       ;; benefits.
       (run-at-time 1 nil (lambda () (setq gc-cons-threshold my-gc-cons-threshold))))

     (add-hook 'minibuffer-setup-hook #'my--defer-garbage-collection)
     (add-hook 'minibuffer-exit-hook  #'my--restore-garbage-collection)
     (add-hook 'focus-out-hook #'garbage-collect)))

  (message "Loaded in %.3fs"
           (float-time (time-subtract (current-time) emacs-start-time))))

(add-hook 'after-init-hook #'my--restore-startup-optimizations nil t)
#+END_SRC

** Common functions

#+BEGIN_SRC emacs-lisp
(eval-and-compile
  (defun fikovnik/recompile-elpa ()
    "Recompile packages in elpa directory"
    (interactive)
    (byte-recompile-directory package-user-dir 0 nil))

  (defun fikovnik/sync-configuration (arg)
    "Tangle the ~/.emacs.d/config.org file into
    ~/.emacs.d/init.el and if called with universal argument also
    byte compile it into ~/.emacs.d/init.elc"

    (interactive "P")
    (let ((config-file (emacs-path "config.org"))
          (init-file (emacs-path "init.el"))
          (init-file-elc (emacs-path "init.elc")))
      (org-babel-tangle-file config-file init-file "emacs-lisp")
      (when (file-exists-p init-file-elc) (delete-file init-file-elc))
      (when arg (byte-compile-file init-file))))

  (defun fikovnik/sync-configuration-and-compile ()
    (interactive)
    (fikovnik/sync-configuration t))

  (defun emacs-path (path)
    (expand-file-name path user-emacs-directory)))
#+END_SRC

** init.el file debugging

#+BEGIN_SRC emacs-lisp
(if init-file-debug
    (setq use-package-verbose t
          use-package-expand-minimally nil
          use-package-compute-statistics t
          debug-on-error t)
  (setq use-package-verbose nil
        use-package-expand-minimally t))
#+END_SRC

** Turn off messages

#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-buffer-menu t)
(setq inhibit-startup-echo-area-message "krikava")
(setq inhibit-startup-message t)
(setq inhibit-startup-screen t)
(setq initial-scratch-message nil)
#+END_SRC

** Initialize package.el

#+BEGIN_SRC emacs-lisp
(package-initialize)
#+END_SRC

** Setup package sources

#+BEGIN_SRC emacs-lisp
(add-to-list 'package-archives
             '("melpa" . "http://melpa.org/packages/") t)
(add-to-list 'package-archives
             '("org" . "http://orgmode.org/elpa/") t)
#+END_SRC

** Initialize use-package

#+BEGIN_SRC emacs-lisp
(setq-default use-package-always-ensure t ; Auto-download package if not exists
              use-package-always-defer t ; Always defer load package to speed up startup
              use-package-verbose nil ; Don't report loading details
              use-package-expand-minimally t  ; make the expanded code as minimal as possible
              use-package-enable-imenu-support t) ; Let imenu finds use-package definitions

(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(eval-when-compile
  (require 'use-package))
#+END_SRC

** Benchmark initialization

Who would not like to benchmark initialization of his text editor?

#+BEGIN_SRC emacs-lisp
(use-package benchmark-init
  :demand t
  :hook
  (after-init . benchmark-init/deactivate))
#+END_SRC

To see the results use either:

#+BEGIN_SRC emacs-lisp :tangle no
(benchmark-init/show-durations-tree)
#+END_SRC

or

#+BEGIN_SRC emacs-lisp :tangle no
benchmark-init/show-durations-tabulated
#+END_SRC

** Install diminish

Allow to use =:diminish= in =use-package= macro to diminish minor mode.

#+BEGIN_SRC emacs-lisp
;; :diminish keyword
(use-package diminish
  :demand t)
#+END_SRC

** Install bind-key

Allow to use =:bind-key= in =use-package= macro to easily bind-keys.

#+BEGIN_SRC emacs-lisp
;; :bind keyword
(use-package bind-key
  :demand t)
#+END_SRC

* Defaults
** Global variables
*** Declarations
#+BEGIN_SRC emacs-lisp
(defvar fikovnik/backup-dir (emacs-path "backups")
  "backup directory")

(defvar fikovnik/savefile-dir (emacs-path "savefile")
  "backup directory")

(defvar fikovnik/my-keys nil
  "The list of keys to be mapped as pairs of keySym and ascii code")

(defvar fikovnik/my-keys-debug nil
  "Toggle my-keys debugging")

(defvar fikovnik/st-dir "~/Projects/st"
  "The location of st terminal sources")

(defvar fikovnik/projects-search-path '("~/Projects" "~/Research/Projects" "~/Research/Publications")
  "Paths where projects are stored. Used in projectile")
#+END_SRC

** ST terminal
Treat st terminal as xterm (cf. https://www.gnu.org/software/emacs/manual/html_node/elisp/Terminal_002dSpecific.html)
#+BEGIN_SRC emacs-lisp
(add-to-list 'term-file-aliases (quote ("st" . "xterm")))
#+END_SRC
** Input map in terminal

This section fixes key bindings in Emacs running in a terminal.

*** Overview

There are several problems in handling key events in the current terminals. For
example:
- it is not possible to use modifiers other than =C-= and =M-=,
- the =C-= modifier encodes lower or upper-case letters identically,
- special names for some ASCII characters collide with =C-= modified letters (e.g., a tab is =C-i=),
- there is no reliable way to use multiple modifier keys, other than, =M-S-=,
- some keys cannot be used with =C-= modifier, eg., =;=, =.=, =/=.

The reason for all of this is that there is no standard for these _corner_
cases. There has been a several proposals:
- [[http://www.leonerd.org.uk/hacks/fixterms/][Paul Evan's fixterms]]
- [[https://sw.kovidgoyal.net/kitty/protocol-extensions.html#extensions-to-the-xterm-protocol][Kitty extension to xterm protocol]]
- [[https://github.com/CyberShadow/term-keys][term-keys package]]
- XTerm's [[https://invisible-island.net/xterm/manpage/xterm.html#VT100-Widget-Resources:formatOtherKeys][formatOtherKeys]] and [[https://invisible-island.net/xterm/manpage/xterm.html#VT100-Widget-Resources:modifyOtherKeys][modifyOtherKeys]] classes

I decided to use Paul's fixterm proposition (which is compatible with XTerm's
solution given =formatOtherKeys= is set to 1). It works as follows: for each
key combination that is not expressible in the current schema it will use the
following escape sequence:

#+BEGIN_SRC text :tangle no
ESC[<key>;<mod>u
#+END_SRC

where
- =key= is the ASCII decimal value of the key
- =mod= is 1 + bitmask encoding of the modifiers
  - =S-= = 1
  - =M-= = 2
  - =C-= = 4

For example, =C-;= sends =\e[59;5u=.

Xterm can do that as well with =formatOtherKeys:1=, which can be verified using:

#+BEGIN_SRC sh :tangle no
xterm -xrm '*modifyOtherKeys:1' -xrm '*formatOtherKeys:1' -e cat -v
#+END_SRC

- With =modifyOtherKeys:2= it can do even =C-m=, =C-j= and =C-i=:
  - =C-m= -- =109;5u=
  - =C-S-m= -- =77;6u=
  - =C-i= -- =105;5u=
  - =C-S-i= -- =73;6u=
  - =C-j= -- =106;5u=
  - =C-S-j= -- =74;5u=
  - =C-`= -- =96;5u=
  - =C-\= -- =92;5u=

For this to work, two things need to be updated:
1. the terminal emulator (st in my case)
2. the emacs's =input-decode-map=

**** Terminal - st

In [[https://st.suckless.org/][st]] (my terminal of choice), one has to modify two places:
1. =mappedkeys= variable in =config.h= which contains a list of
   custom-mapped keys:

   #+BEGIN_SRC c :tangle no
   XK_semicolon
   #+END_SRC

2. =keys= variable in =config.h= containing the actual mapping:

   #+BEGIN_SRC c :tangle no
   {XK_semicolon, ControlMask, "\033[59;5u", 0, 0}
   #+END_SRC

**** Emacs

In emacs we only need to add the corresponding binding into the
=input-decode-map=:

#+BEGIN_SRC emacs-lisp :tangle no
(define-key input-decode-map "\e[59;5u" (kbd "C-;"))
#+END_SRC

**** Notes about upper/lower keys binding

From Emacs _Key Sequence Input_:

#+BEGIN_QUOTE
If an input character is upper-case (or has the shift modifier) and has no
key binding, but its lower-case equivalent has one, then read-key-sequence'
converts the character to lower case. Note that lookup-key' does not perform
case conversion in this way.
#+END_QUOTE
**** Notes about [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Key-Sequences.html#Key-Sequences][Key Sequences]] in Emacs
- The Emacs Lisp representation for a key sequence is a string or vector.
- The =kbd= macro returns a representation of a key sequence using some sort of
  translation.
- It is also possible to bind keys using a vector like =[C-S-M]= which will
  create a =<C-M>= binding, a different from =C-S-M=.
*** Configuration
**** Default keys

#+BEGIN_SRC emacs-lisp
(setq fikovnik/my-keys-debug nil
      fikovnik/my-keys '((?\; "XK_semicolon"    ("C" "C-M"))
                         (?:  "XK_colon"        ("C-S" "C-M-S"))
                         (?'  "XK_apostrophe"   ("C" "C-M"))
                         (?\" "XK_quotedbl"     ("C-S" "C-M-S"))
                         (?.  "XK_period"       ("C" "C-M"))
                         (?,  "XK_comma"        ("C" "C-M"))
                         (?=  "XK_equal"        ("C" "C-M"))
                         (?<  "XK_less"         ("C-S" "C-M-S"))
                         (?>  "XK_greater"      ("C-S" "C-M-S"))
                         (??  "XK_question"     ("C-S" "C-M-S"))
                         (?/  "XK_slash"        ("C" "C-M"))
                         (?\\ "XK_backslash"    ("C" "C-M"))
                         (?|  "XK_bar"          ("C-S" "C-M-S"))
                         (?~  "XK_asciitilde"   ("C-S" "C-M-S"))
                         (?`  "XK_grave"        ("C" "C-S"))
                         (?{  "XK_braceleft"    ("C-S" "C-M-S"))
                         (?}  "XK_braceright"   ("C-S" "C-M-S"))
                         (?\] "XK_bracketright" ("C" "C-M"))
                         (?\( "XK_parenleft"    ("C-S" "C-M-S"))
                         (?\) "XK_parenright"   ("C-S" "C-M-S"))
                         (?C  "XK_C"            ("C-S" "C-M-S"))
                         (?X  "XK_X"            ("C-S" "C-M-S"))
                         (?V  "XK_V"            ("C-S" "C-M-S"))
                         (?I  "XK_I"            ("C-S" "C-M-S"))
                         (?M  "XK_M"            ("C-S" "C-M-S"))
                         (?J  "XK_J"            ("C-S" "C-M-S"))
                         (?m  "XK_m"            ("C" "C-M")               (([C-m]) ([C-M-m])))
                         (?i  "XK_i"            ("C" "C-M")               (([C-i]) ([C-M-i])))
                         (?O  "XK_O"            ("C-S" "C-M-S"))
                         (? "XK_BackSpace"    ("C" "C-M" "C-S" "C-M-S") (([C-]) ([C-M-]) ([C-S-]) ([C-M-S-])))
                         ))
#+END_SRC

- The =C-m=, =C-M-m, =C-i= and =C-M-i= can be bind using symbol =[C-m]=, etc.
  They are not =C-m=, but =<C-m>= from Emacs perspective.
- It would be possible to map as well =C-j= but that is handy for inserting the
  new line literal (using =C-q=) for example for replace.

**** =C-<number>= and =C-M-<number>= keys

#+BEGIN_SRC emacs-lisp
(let ((nums '(1 2 3 4 5 6 7 8 9)))
  (mapc (lambda (x)
          ;; DEC 48 is '0' in ASCII table
          (let* ((code (+ 48 x))
                 (e (list code (format "XK_%d" x) (list "C" "C-M"))))
            (setq fikovnik/my-keys (append fikovnik/my-keys (list e)))))
        nums))
#+END_SRC

**** Auxiliary functions

#+BEGIN_SRC emacs-lisp
(defun flatten (list-of-lists)
  (apply #'append list-of-lists))

(defun join (sep lst)
   (mapconcat 'identity lst sep))

 (defun zip (xs ys)
   (if (and (null xs) (null ys))
       ()
     (cons (cond
            ((null xs) (cons '(nil) (car ys)))
            ((null ys) (cons (car xs) '(nil)))
            (t (cons (car xs) (car ys))))
           (zip (cdr xs) (cdr ys)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defconst fikovnik/-my-keys-prefix "\033["
  "Escape code sequence prefix")

(defconst fikovnik/-my-keys-suffix "u"
  "Escape code sequence suffix")

(defconst fikovnik/-my-keys-modifiers
  '(("M"     . ("Mod1Mask"                           3))
    ("M-S"   . ("Mod1Mask | ShiftMask"               4))
    ("C"     . ("ControlMask"                        5))
    ("C-S"   . ("ControlMask | ShiftMask"            6))
    ("C-M"   . ("ControlMask | Mod1Mask"             7))
    ("C-M-S" . ("ControlMask | Mod1Mask | ShiftMask" 8)))
  "The key modifiers as triplets of st emacs name, st name and code")

(defun fikovnik/-encode-key-mod (key-code mod-code)
  (format "%s%d;%d%s" fikovnik/-my-keys-prefix key-code mod-code fikovnik/-my-keys-suffix))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun fikovnik/-iterate-keys (fun)
  (mapcan
   (lambda (key)
     (let ((key-code (car key))
           (key-sym (cadr key))
           (mods (caddr key))
           (keys-emacs (cadddr key)))
       (mapcar
        (lambda (x)
          (let* ((mod (car x))
                 (key-emacs (cadr x))
                 (mod-info (cdr (assoc mod fikovnik/-my-keys-modifiers))))
            (funcall fun key-code key-sym mod mod-info key-emacs)))
        (zip mods keys-emacs))))
   fikovnik/my-keys))
#+END_SRC

**** Enabling my-keys in st

#+BEGIN_SRC emacs-lisp
(defun fikovnik/-escape-string (s)
  (mapconcat
   (lambda (x)
     (if (and (>= x 32) (<= x 255))
         (format "%c" x)
       (format "\\x%02X" x)))
   (append s nil)
   ""))

(defun fikovnik/-st-encode-keys ()
  (delete-dups
   (fikovnik/-iterate-keys
    (lambda (key-code key-sym mod mod-info key-emacs)
      (let ((mod-sym (car mod-info))
            (mod-code (cadr mod-info)))
        (format "{%s, %s, \"%s\", 0, 0}"
                key-sym
                mod-sym
                (fikovnik/-escape-string (fikovnik/-encode-key-mod key-code mod-code))))))))

(defun fikovnik/-st-encode-mapped-keys ()
  (delete-dups
   (fikovnik/-iterate-keys
    (lambda (key-code key-sym mod mod-info key-emacs)
      (format "%s" key-sym)))))

(defun fikovnik/st-sync-mapped-keys ()
  (interactive)
  (with-temp-buffer
    (insert (concat (join ",\n" (fikovnik/-st-encode-keys)) ",\n"))
    (write-region (point-min) (point-max) (expand-file-name "my-keys.h" fikovnik/st-dir)))

  (with-temp-buffer
    (insert (concat (join ",\n" (fikovnik/-st-encode-mapped-keys)) ",\n"))
    (write-region (point-min) (point-max) (expand-file-name "my-mapped-keys.h" fikovnik/st-dir))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
(fikovnik/st-sync-mapped-keys)
#+END_SRC

**** Enabling my-keys in Emacs

Make Emacs aware of these new keys using the [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Translation-Keymaps.html][input-decode-map]].

#+BEGIN_SRC emacs-lisp
(defun fikovnik/emacs-encode-keys ()
  (fikovnik/-iterate-keys
   (lambda (key-code key-sym mod mod-info key-emacs)
     (let* ((mod-code (cadr mod-info))
            (input (fikovnik/-encode-key-mod key-code mod-code))
            (key (if (null key-emacs)
                     (kbd (format "%s-%c" mod key-code))
                   key-emacs)))
       (when fikovnik/my-keys-debug
         (message "binding: %s to %s (%s-%c)" input key mod key-code))

       ;(define-key input-decode-map input key)
       (define-key xterm-function-map input key)))))

(when fikovnik/my-keys
  (message "Enabling my-keys")
  (eval-after-load "xterm" '(fikovnik/emacs-encode-keys)))
;;(unless (display-graphic-p)
;;  (fikovnik/emacs-encode-keys))
#+END_SRC

**** TODO should this go the the xterm-function-map instead?
- try it in GUI to see what works better
- try it in Xterm
- try term keys
** TODO input map in GUI
- sync it with terminal
** Customize file =custom.el=                                          :wip:

Set up the customize file to its own separate file, instead of saving
customize settings in [[file:init.el][init.el]].

*** TODO what to do with the custom file? Keep it, keep it, but not version it or send to /tmp

#+BEGIN_SRC emacs-lisp
(setq custom-file (emacs-path "custom.el"))
(unless (file-exists-p custom-file)
    (write-region "" nil custom-file))
;(load custom-file)
#+END_SRC

** Install hydra

#+BEGIN_SRC emacs-lisp
(use-package hydra)
#+END_SRC

** Install smartrep                                           :experimental:

I would prefer to use hydra for all, but it somehow does not work with multiple
cursors.

#+BEGIN_SRC emacs-lisp
(use-package smartrep
  :custom
  (smartrep-mode-line-string-activated "[SR]")
  ;; no modeline higlighting
  (smartrep-mode-line-active-bg (face-background 'mode-line))
)
#+END_SRC

** Enable some useful functions

These functions are useful so activate them.

#+BEGIN_SRC emacs-lisp
(put 'downcase-region 'disabled nil)
(put 'upcase-region 'disabled nil)
(put 'narrow-to-region 'disabled nil)
(put 'dired-find-alternate-file 'disabled nil)
(put 'erase-buffer 'disabled nil)
(put 'scroll-left 'disabled nil)
#+END_SRC

** File backup                                                         :wip:
*** TODO better way to handle backups
*** TODO document how does it exactly work

#+BEGIN_SRC emacs-lisp
(setq
      auto-save-list-file-name           (concat user-emacs-directory "/autosave")
      backup-directory-alist            `((".*" . ,fikovnik/backup-dir))
      ;;auto-save-file-name-transforms    `((".*" ,(concat user-emacs-directory "/auto-save-list/") t))
      version-control                    t
      backup-by-copying                  t
      delete-old-versions                t
      kept-new-versions                  6
      kept-old-versions                  2
      history-length                     1000
      backup-inhibited                   nil
      make-backup-files                  t
      auto-save-default                  t
      create-lockfiles                   nil
)
#+END_SRC
*** TODO backup walker
** Auto save file buffers

Automatically save buffers associated with files on buffer switch
and on windows switch.

#+BEGIN_SRC emacs-lisp
(use-package super-save
  :defer 2
  :unless noninteractive
  :diminish (super-save-mode . "AS")
  :config
  ;; add integration with ace-window
  (add-to-list 'super-save-triggers 'ace-window)
  (add-to-list 'super-save-hook-triggers 'find-file-hook)
  (super-save-mode +1))
#+END_SRC

** Use UTF-8

#+BEGIN_SRC emacs-lisp
(prefer-coding-system 'utf-8)

;; Accept 'UTF-8' (uppercase) as a valid encoding in the coding header
(define-coding-system-alias 'UTF-8 'utf-8)
#+END_SRC

** Sensible defaults

Taken mostly from the [[https://github.com/hrs/sensible-defaults.el/blob/master/sensible-defaults.el][sensible-defaults.el]] and [[http://www.emacs-bootstrap.com/][emacs-bootstrap]].

*** Eval expression

#+BEGIN_SRC emacs-lisp
(bind-key "M-:" 'eval-expression)
#+END_SRC

*** Yes/No confirmation

Answering just 'y' or 'n' will do

#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

*** Defaults

#+BEGIN_SRC emacs-lisp
(setq
      ;; apropos searches more extensively
      apropos-do-all                      t
      ;; indent or if indeneted, complete
      tab-always-indent                   'complete
      confirm-nonexistent-file-or-buffer  t

      ;; save existing clipboard into kill ring before replacing it
      save-interprogram-paste-before-kill t
      ;; when middle-clicking the mouse to yank from the clipboard, insert the text where point is, not where the mouse cursor is
      mouse-yank-at-point                 t
      require-final-newline               t
      visible-bell                        t
      ;; http://ergoemacs.org/emacs/emacs_stop_cursor_enter_prompt.html
      minibuffer-prompt-properties        '(read-only t point-entered minibuffer-avoid-prompt face minibuffer-prompt)
      ;; Disable non selected window highlight
      cursor-in-non-selected-windows      nil
      highlight-nonselected-windows       nil
      ;; PATH
      exec-path                           (append exec-path '("/usr/local/bin/"))
      ;; single space to indicate end of a sentance
      sentence-end-double-space           nil
      select-enable-clipboard             t
      ;; -i gets alias definitions from shell
      shell-command-switch                "-ic"
      echo-keystrokes                     0.1
      use-dialog-box                      nil
      kill-ring-max                       300
      initial-major-mode                  'text-mode
      cursor-in-non-selected-windows      t
      ;; when opening a file, follow symlinks
      vc-follow-symlinks                  t
      require-final-line                  t
      ;; Activate character folding in searches i.e. searching for 'a' matches 'ä' as well
      search-default-mode                 'char-fold-to-regexp
)

(setq-default
      ;; always just use left-to-right text this makes Emacs a bit faster for very long lines
      bidi-display-reordering             nil
      tab-width                           2
      indent-tabs-mode                    nil
      ;; maximum line width
      fill-column                         79
      ;; don't fold lines
      truncate-lines                      t
      frame-title-format                  '("%b")
      indicate-empty-lines                t
      cursor-type                         'bar
      display-line-numbers-grow-only      t
      display-line-numbers-width-start    t
      show-paren-delay                    0.0
      imenu-auto-rescan                   t
)

(blink-cursor-mode -1)
(delete-selection-mode t)
(show-paren-mode t)
(column-number-mode t)
(global-visual-line-mode t)
(global-hl-line-mode t)
;; when something changes a file, automatically refresh the buffer containing
;; that file so they can't get out of sync.
(global-auto-revert-mode t)
(transient-mark-mode t)
(toggle-truncate-lines t)
(whitespace-mode -1)
(size-indication-mode t)

(diminish 'visual-line-mode " ↩")
#+END_SRC
*** Enable line numbers

#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook #'display-line-numbers-mode)
(add-hook 'text-mode-hook #'display-line-numbers-mode)
#+END_SRC

*** Nicer scrolling

#+BEGIN_SRC emacs-lisp
(setq scroll-margin 0
      scroll-step 1
      scroll-error-top-bottom t
      scroll-conservatively 100000
      scroll-preserve-screen-position 1
      ;; disable auto vscroll (makes scrolling down a bit faster?)
      auto-window-vscroll nil)
#+END_SRC

**** TODO make sure this work with the pdf-tools

*** Turn on syntax highlighting whenever possible

#+begin_src emacs-lisp
(global-font-lock-mode t)
#+end_src

*** When saving a file that starts with =#!=, make it executable

#+BEGIN_SRC emacs-lisp
(add-hook 'after-save-hook
          'executable-make-buffer-file-executable-if-script-p)
#+END_SRC

*** Popup window management

#+BEGIN_SRC emacs-lisp
(use-package popwin
  :demand t
  :config
  (popwin-mode 1))
#+END_SRC

The package seems not to be maintained, an alternative might be [[https://github.com/wasamasa/shackle][shackle]].
*** TODO replace popwin with better one
*** Save placesss

This remembers your location in a file when saving files.

#+BEGIN_SRC emacs-lisp
(use-package saveplace
  :demand t
  :unless noninteractive
  :custom
  (save-place-file (expand-file-name "saveplace" fikovnik/savefile-dir)))

(save-place-mode 1)
#+END_SRC
*** Meaningful names for buffers with the same name

#+BEGIN_SRC emacs-lisp
(setq uniquify-buffer-name-style 'forward
      uniquify-separator "/"
      ;; rename after killing uniquified
      uniquify-after-kill-buffer-p t
      ;; don't muck with special buffers
      uniquify-ignore-buffers-re "^\\*")
#+END_SRC

*** Track history

#+BEGIN_SRC emacs-lisp
;; savehist keeps track of some history
(use-package savehist
  :demand t
  :unless noninteractive
  :custom
  ;; search entries
  (savehist-additional-variables '(search-ring regexp-search-ring compile-command kill-ring))
  ;; save every minute
  (savehist-autosave-interval 60)
  ;; keep the home clean
  (savehist-file (expand-file-name "savehist" fikovnik/savefile-dir))
  :config
  (savehist-mode 1))
#+END_SRC

*** Recent files tracking

#+BEGIN_SRC emacs-lisp
(use-package recentf
  :demand t
  :custom
  (recentf-save-file (expand-file-name "recentf" fikovnik/savefile-dir))
  (recentf-max-saved-items 500)
  (recentf-max-menu-items 15)
  ;; disable recentf-cleanup on Emacs start, because it can cause
  ;; problems with remote files
  (recentf-auto-cleanup 'never)
  :config
  (recentf-mode +1))
#+END_SRC
*** <end> is the same as =C-e=

#+BEGIN_SRC emacs-lisp
(bind-key "<end>" #'move-end-of-line)
#+END_SRC

** Install crux

This package defines a bunch of useful functions that I would otherwise had to
define.

#+BEGIN_SRC emacs-lisp
(use-package crux
  :commands
  crux-smart-open-line-above
  crux-smart-open-line
  crux-open-with
  crux-top-join-line
  crux-rename-file-and-buffer
  crux-with-region-or-line
  crux-kill-line-backwards
  crux-kill-whole-line)
#+END_SRC

These command will be used in the [[Editing]] and [[Navigation]].

** Minibuffer

#+BEGIN_SRC emacs-lisp
(use-package minibuffer
  :ensure nil
  :config
  (defun my-minibuffer-setup-hook ()
    (setq gc-cons-threshold most-positive-fixnum))

  (defun my-minibuffer-exit-hook ()
    (setq gc-cons-threshold 800000))

  (add-hook 'minibuffer-setup-hook #'my-minibuffer-setup-hook)
  (add-hook 'minibuffer-exit-hook #'my-minibuffer-exit-hook))
#+END_SRC

* Editing
** Killing lines

#+BEGIN_SRC emacs-lisp
(bind-key [remap kill-while-line] #'crux-kill-whole-line)
(bind-key [C-] #'crux-kill-line-backwards)
#+END_SRC

** Deleting spaces

| Key     | Description                                                | Function                 |
|---------+------------------------------------------------------------+--------------------------|
| =M-\=   | Delete all spaces and tabs around point                    | =delete-horizonal-space= |
| =M-SPC= | Delete all spaces and tabs around point, leaving one space | =just-one-space=         |

** Copy and paste
*** Functions

These functions allow to C&P to the system clipboard using either terminal
escape code or xsel command if running in GUI.

#+BEGIN_SRC emacs-lisp
(defun fikovnik/copy-to-xclipboard ()
  (interactive)
  (if (use-region-p)
      (if (not (display-graphic-p))
          (letrec ((s (buffer-substring-no-properties (region-beginning) (region-end)))
                   (s-length (+ (* (length s) 3) 2)))
            (if (<= s-length 16384) ; magic number set to the same as ESC_BUF_SIZ of suckless termial (st.c)
                (progn
                  (send-string-to-terminal (concat "\e]52;c;"
                                                   (base64-encode-string (encode-coding-string s 'utf-8) t)
                                                   "\07"))
                  (message "Yanked region to terminal clipboard")
                  (deactivate-mark))
              (message "Selection too long (%d) to send to terminal." s-length)))
        (if (= 0 (shell-command-on-region (region-beginning) (region-end) "xsel -i -b"))
            (message "Yanked region to X-clipboard")
          (error "Is program `xsel' installed?")))
    (message "Nothing to yank to terminal clipboard")))

(defun fikovnik/cut-to-xclipboard ()
  (interactive)
  (fikovnik/copy-to-xclipboard)
  (kill-region (region-beginning) (region-end)))

(defun fikovnik/paste-from-xclipboard ()
  "Uses shell command `xsel -o' to paste from x-clipboard. With
one prefix arg, pastes from X-PRIMARY, and with two prefix args,
pastes from X-SECONDARY."
  (interactive)
  (if (display-graphic-p)
      (clipboard-yank)
    (letrec
        ((opt (prefix-numeric-value current-prefix-arg))
         (opt (cond
               ((=  1 opt) "b")
               ((=  4 opt) "p")
               ((= 16 opt) "s"))))
(insert (shell-command-to-string (concat "xsel -o -" opt))))))
#+END_SRC

*** Bind keys

Bind =C-S-X= to cut and =C-X-C= to copy.

#+BEGIN_SRC emacs-lisp
(bind-key "C-S-X" 'fikovnik/cut-to-xclipboard)
(bind-key "C-S-C" 'fikovnik/copy-to-xclipboard)
#+END_SRC

The paste shortcut (=C-S-V=) we only want in GUI. When running in terminal it
is better to use the terminal paste since it will be a [[https://cirw.in/blog/bracketed-paste][bracketed paste]].

#+BEGIN_SRC emacs-lisp
(when (display-graphic-p)
  (bind-key "C-S-V" 'fikovnik/paste-from-xclipboard))
#+END_SRC

** Fill/unfill paragraph

#+BEGIN_SRC emacs-lisp
(use-package unfill
  :commands (unfill-region unfill-paragraph unfill-toggle)
  :bind
  ([remap fill-paragraph] . unfill-toggle))
#+END_SRC

** Multiple cursors

#+BEGIN_SRC emacs-lisp
(global-unset-key (kbd "M-m"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
  :config
  (smartrep-define-key global-map "M-m"
    '(("n" . 'mc/mark-next-like-this)
      ("u" . 'mc/unmark-next-like-this)
      ("s" . 'mc/skip-to-next-like-this)
      ("N" . 'mc/mark-previous-like-this)
      ("U" . 'mc/unmark-previous-like-this)
      ("S" . 'mc/skip-to-previous-like-this)
      ;; TODO: this should be (er/mark-word) followed by (mc/hydra)
      ("m" . 'mc/mark-more-like-this-extended)
      ("a" . 'mc/mark-all-like-this)
      ("d" . 'mc/mark-all-like-this-dwim)
      ("r" . 'mc/reverse-regions))))
#+END_SRC
** TODO replace multiple cursors with iedit?
** Move lines up / down
*** TODO fix this in org-mode which takes over this binding

#+BEGIN_SRC emacs-lisp
(use-package move-dup
  :bind
  ("M-<up>" . md-move-lines-up)
  ("M-<down>" . md-move-lines-down)
  ("M-S-<up>" . md-duplicate-up)
  ("M-S-<down>" . md-duplicate-down))
#+END_SRC

** Join lines

The =join-line= command (aliased to =delete-indentation=) works from the last
line to be joined upwards. Most of the time I prefer the other way around.

| Key   | Description                                       |
|-------+---------------------------------------------------|
| =M-j= | Join the current line with the line *beneath* it. |
| =M-J= | Join the current line with the line *over* it.    |

#+BEGIN_SRC emacs-lisp
(bind-key "M-j" #'crux-top-join-line)
(bind-key "M-J" #'join-line)
#+END_SRC

** Open line above and bellow

#+BEGIN_SRC emacs-lisp
(bind-key "C-S-O" #'crux-smart-open-line-above)
(bind-key "C-o" #'crux-smart-open-line)
#+END_SRC

** Comment / un-comment lines

First, we extend the functionality of the =comment-or-uncomment-region= to work
on a single line in the case no region is active:

#+BEGIN_SRC emacs-lisp
(crux-with-region-or-line comment-or-uncomment-region)
#+END_SRC

Next, we bind it:

#+BEGIN_SRC emacs-lisp
(bind-key "C-/" #'comment-or-uncomment-region)
#+END_SRC

** Copy and cut whole lines

If no region is active, make the =M-w= and =C-w= copy and cut whole line
respectivelly.

#+BEGIN_SRC emacs-lisp
(crux-with-region-or-line kill-region)
(crux-with-region-or-line kill-ring-save)
#+END_SRC

** Expand region (=C-==)

Define a function that simply selects the current line.

#+BEGIN_SRC emacs-lisp
(defun fikovnik/select-line ()
  "Select current line. If region is active, extend selection downward by line."
  (interactive)
  (if (region-active-p)
      (progn
        (forward-line 1)
        (end-of-line))
    (progn
      (end-of-line)
      (set-mark (line-beginning-position)))))
#+END_SRC

Define the =M-r= prefix and use it for expand region, including the line
selection defined above.

#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :bind (:prefix "C-="
         :prefix-map my-expand-region-map
         ("="  . er/expand-region)
         ("("  . er/mark-inside-pairs)
         (")"  . er/mark-outside-pairs)
         ("'"  . er/mark-inside-quotes)
         ("\"" . er/mark-outside-quotes)
         ("o" . er/mark-org-parent)
         ("u" . er/mark-url)
         ("b" . er/mark-org-code-block)
         ("." . er/mark-method-call)
         (">" . er/mark-next-accessor)
         ("w" . er/mark-word)
         ("d" . er/mark-defun)
         ("e" . er/mark-email)
         ("," . er/mark-symbol)
         ("<" . er/mark-symbol-with-prefix)
         (";" . er/mark-comment)
         ("s" . er/mark-sentence)
         ("S" . er/mark-text-sentence)
         ("p" . er/mark-paragraph)
         ("P" . er/mark-text-paragraph)
         ("l" . fikovnik/select-line)))
#+END_SRC

** Snippets                                                          :hydra:

#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :defer 1
  :diminish (yas-minor-mode . "YAS")
  :commands yas-minor-mode
  :bind
  ("C-c S" . hydra-yas/body)
  :config
  (defhydra hydra-yas (:exit t :hint nil)
    ("i" yas-insert-snippet "insert")
    ("n" yas-new-snippet "new")
    ("f" yas-visit-snippet-file "visit")
    ("r" yas-reload-all "reload")
    ("x" yas-expand "expand")
    ("t" yas-tryout-snippet "try")
    ("l" yas-describe-tables "list"))
  (yas-global-mode 1)
  (yas-reload-all))
#+END_SRC

** Auto completion
*** Company mode

#+BEGIN_SRC emacs-lisp
(use-package company
  :defer 2
  :diminish (company-mode . "AC")
  :commands (company-mode company-indent-or-complete-common)
  :custom
  (company-idle-delay 0.1)
  (company-tooltip-limit 10)
  (company-minimum-prefix-length 2)
  (company-tooltip-align-annotations t)
  (company-begin-commands '(self-insert-command))
  (company-dabbrev-ignore-case t)
  (company-dabbrev-code-ignore-case t)
  (company-dabbrev-downcase nil)
  :hook
  (after-init . global-company-mode)
  :bind (:map company-active-map
              ([tab] . nil)
              ("TAB" . nil)))
#+END_SRC

**** [[https://github.com/expez/company-quickhelp][company-quick-help]]

#+BEGIN_SRC emacs-lisp
(use-package company-quickhelp
  :after company
  :bind (:map company-active-map
              ("C-c ?" . company-quickhelp-manual-begin)))
#+END_SRC

*** Hippie expand

#+BEGIN_SRC emacs-lisp
(use-package hippie-exp
  :bind
  ([remap dabbrev-expand] . hippie-expand)
  :custom
  (hippie-expand-try-functions-list '(try-expand-dabbrev
                                      try-expand-dabbrev-all-buffers
                                      try-expand-dabbrev-from-kill
                                      try-complete-file-name-partially
                                      try-complete-file-name
                                      try-expand-all-abbrevs
                                      try-expand-list
                                      try-expand-line
                                      try-complete-lisp-symbol-partially
                                      try-complete-lisp-symbol)))
#+END_SRC

** TODO delete syntax
** Spell checking
*** Configuration

Spell check using aspell.

#+BEGIN_SRC emacs-lisp
(use-package ispell
  :no-require t
  :bind (:prefix "C-c s"
         :prefix-map my-ispell-map
         ("c" . ispell-comments-and-strings)
         ("d" . ispell-change-dictionary)
         ("k" . ispell-kill-ispell)
         ("m" . ispell-message)
         ("r" . ispell-region)
         ("b" . ispell-buffer)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package flyspell
  :hook
  (text-mode . flyspell-mode)
  (prog-mode . flyspell-prog-mode)
  :custom
  (ispell-program-name "aspell")
  (ispell-extra-args '("--sug-mode=ultra")))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package flyspell-correct-ivy
  :bind
  ("M-'" . flyspell-correct-at-point)
  (:map my-ispell-map
        ("s" . flyspell-correct-wrapper)))
#+END_SRC

** TODO surround
- https://github.com/ganmacs/emacs-surround
** Rainbow delimiters

#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :hook
  (prog-mode . rainbow-delimiters-mode))
#+END_SRC
** TODO highlight-parenthesis-mode?
** TODO smartparens

from: https://ensime.github.io/editors/emacs/hacks/#general
#+BEGIN_SRC emacs-lisp :tangle no
(use-package smartparens
  :diminish smartparens-mode
  :commands
  smartparens-strict-mode
  smartparens-mode
  sp-restrict-to-pairs-interactive
  sp-local-pair
  :init
  (setq sp-interactive-dwim t)
  :config
  (require 'smartparens-config)
  (sp-use-smartparens-bindings)

  (sp-pair "(" ")" :wrap "C-(") ;; how do people live without this?
  (sp-pair "[" "]" :wrap "s-[") ;; C-[ sends ESC
  (sp-pair "{" "}" :wrap "C-{")

  ;; WORKAROUND https://github.com/Fuco1/smartparens/issues/543
  (bind-key "C-<left>" nil smartparens-mode-map)
  (bind-key "C-<right>" nil smartparens-mode-map)

  (bind-key "s-<delete>" 'sp-kill-sexp smartparens-mode-map)
  (bind-key "s-<backspace>" 'sp-backward-kill-sexp smartparens-mode-map))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
(use-package smartparens
  :defer 1
  :hook ((
          emacs-lisp-mode lisp-mode hy-mode go-mode cc-mode
          python-mode typescript-mode javascript-mode java-mode
          ) . smartparens-strict-mode)
  ;; :hook (prog-mode . smartparens-strict-mode)
  :bind (:map smartparens-mode-map
         ;; This is the paredit mode map minus a few key bindings
         ;; that I use in other modes (e.g. M-?)
         ("C-M-f" . sp-forward-sexp) ;; navigation
         ("C-M-b" . sp-backward-sexp)
         ("C-M-u" . sp-backward-up-sexp)
         ("C-M-d" . sp-down-sexp)
         ("C-M-p" . sp-backward-down-sexp)
         ("C-M-n" . sp-up-sexp)
         ("M-s" . sp-splice-sexp) ;; depth-changing commands
         ("M-r" . sp-splice-sexp-killing-around)
         ("M-(" . sp-wrap-round)
         ("C-)" . sp-forward-slurp-sexp) ;; barf/slurp
         ("C-<right>" . sp-forward-slurp-sexp)
         ("C-}" . sp-forward-barf-sexp)
         ("C-<left>" . sp-forward-barf-sexp)
         ("C-(" . sp-backward-slurp-sexp)
         ("C-M-<left>" . sp-backward-slurp-sexp)
         ("C-{" . sp-backward-barf-sexp)
         ("C-M-<right>" . sp-backward-barf-sexp)
         ("M-S" . sp-split-sexp) ;; misc
         ("M-j" . sp-join-sexp))
  :config
  (require 'smartparens-config)
  (setq sp-base-key-bindings 'paredit)
  (setq sp-autoskip-closing-pair 'always)

  ;; Always highlight matching parens
  (show-smartparens-global-mode +1)
  (setq blink-matching-paren nil)  ;; Don't blink matching parens

  ;; Create keybindings to wrap symbol/region in pairs
  (defun prelude-wrap-with (s)
    "Create a wrapper function for smartparens using S."
    `(lambda (&optional arg)
       (interactive "P")
       (sp-wrap-with-pair ,s)))
  (define-key prog-mode-map (kbd "M-(") (prelude-wrap-with "("))
  (define-key prog-mode-map (kbd "M-[") (prelude-wrap-with "["))
  (define-key prog-mode-map (kbd "M-{") (prelude-wrap-with "{"))
  (define-key prog-mode-map (kbd "M-\"") (prelude-wrap-with "\""))
  (define-key prog-mode-map (kbd "M-'") (prelude-wrap-with "'"))
  (define-key prog-mode-map (kbd "M-`") (prelude-wrap-with "`"))

  ;; smart curly braces
  (sp-pair "{" nil :post-handlers
           '(((lambda (&rest _ignored)
                (crux-smart-open-line-above)) "RET")))
  (sp-pair "[" nil :post-handlers
           '(((lambda (&rest _ignored)
                (crux-smart-open-line-above)) "RET")))
  (sp-pair "(" nil :post-handlers
           '(((lambda (&rest _ignored)
                (crux-smart-open-line-above)) "RET")))

  ;; use smartparens-mode everywhere
  (smartparens-global-mode))
#+END_SRC

** TODO indentation

#+BEGIN_SRC emacs-lisp :tangle no
(defun indent-buffer ()
  "Indent the entire buffer."
  (interactive)
  (save-excursion
    (delete-trailing-whitespace)
    (indent-region (point-min) (point-max) nil)
    (untabify (point-min) (point-max))))
#+END_SRC

** TODO macros
- hydra with dribble / loosage
** Automatically remove trailing whitespace

But, only if I put them there!

#+BEGIN_SRC emacs-lisp
(use-package ws-butler
  :hook ((text-mode prog-mode) . ws-butler-mode)
  :config (setq ws-butler-keep-whitespace-before-point nil))
#+END_SRC

** Regexp builder

#+BEGIN_SRC emacs-lisp
(use-package re-builder
  :defer t
  :config (setq reb-re-syntax 'string))
#+END_SRC

* Movement and navigation
** Generic completion with Ivy

#+BEGIN_SRC emacs-lisp
(use-package ivy
  :demand t
  :bind
  ("C-x f" . counsel-fzf)
  ("C-x C-r" . ivy-resume)
  ("C-x C-b" . ivy-switch-buffer)
  ("C-h F" . counsel-faces)
  ([remap isearch-forward] . swiper)
  ([remap isearch-backward] . swiper)
  (:map ivy-mode-map
        ("C-'" . ivy-avy)
        ("C-w" . ivy-yank-word))
  (:map read-expression-map
        ("C-r" . counsel-expression-history))
  (:map minibuffer-local-map
        ("C-r" . counsel-minibuffer-history))
  :custom
  (enable-recursive-minibuffers t)
  (ivy-height 15)
  (ivy-count-format "(%d/%d) ")
  (ivy-use-virtual-buffers t)
  (ivy-virtual-abbreviate 'full)
  (ivy-initial-inputs-alist nil)
  (ivy-use-selectable-prompt t)
  (ivy-on-del-error-function nil)
  (ivy-re-builders-alist
   '((t . ivy--regex-ignore-order)))
  (swiper-action-recenter t)

  (counsel-find-file-at-point t)
  ;; Use rg as backend for counsel-git
  (counsel-git-cmd "rg -S --files")
  ;; max preview and follow symlinks
  (counsel-rg-base-command "rg --max-columns 160 --smart-case --no-heading --line-number --follow --color never %s .")
  ;; use rg instad of grep
  (counsel-grep-base-command "rg --max-columns 160 --smart-case --no-heading --line-number --color never  %s %s")
  :config
  (ivy-mode 1)
  (counsel-mode 1))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package ivy-hydra
  :after (ivy hydra))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package ivy-rich
  :demand t
  :custom
  (ivy-rich-parse-remote-buffer nil)
  (ivy-rich-path-style 'abbrev)
  :config
  (ivy-rich-mode 1))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package smex
  :custom
  (smex-history-length 50))
#+END_SRC

*** TODO better colors for the match

** Imenu

#+BEGIN_SRC emacs-lisp
(use-package imenu
  :ensure nil
  :hook
  (imenu-after-jump . recenter)
  :bind
  ("M-i" . imenu))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package imenu-anywhere
  :bind
  ("M-I" . ivy-imenu-anywhere))
#+END_SRC

** Xref

#+BEGIN_SRC emacs-lisp
(use-package ivy-xref
  :after (ivy xref)
  :config
  (setq xref-show-xrefs-function #'ivy-xref-show-xrefs))
#+END_SRC

** Windows (=C-c w=)
*** Overview

| Key         | Description                          | Function      |
|-------------+--------------------------------------+---------------|
| =C-c left=  | Undo changes in window configuration | =winner-undo= |
| =C-c right= | Redo changes in window configuration | =winner-redo= |
| =C-x o=     | Select window using Avy              | =ace-window=  |

*** Selecting windows

**** Windmove

Windmove defines functions to easily select windows. We do not use the default
keybinding, instead it is bound by the =hydra-window=.

#+BEGIN_SRC emacs-lisp
(use-package windmove
  :demand t
  :custom
  (windmove-wrap-around t)
  :config
  (windmove-default-keybindings)
  (add-hook 'org-shiftup-final-hook 'windmove-up)
  (add-hook 'org-shiftleft-final-hook 'windmove-left)
  (add-hook 'org-shiftdown-final-hook 'windmove-down)
  (add-hook 'org-shiftright-final-hook 'windmove-right))
#+END_SRC

**** Other window, previous on =C-,= and =C-.=

#+BEGIN_SRC emacs-lisp
(defun prev-window ()
  (interactive)
  (other-window -1))

(bind-key "C-," #'prev-window)
(bind-key "C-." #'other-window)
#+END_SRC

*** Save window layout stack using the =winner-mode=

This will allow to go back/fort between window layouts.

#+BEGIN_SRC emacs-lisp
(use-package winner
  :demand t
  :config
  (winner-mode 1))
#+END_SRC

*** Jump between windows

Use [[https://github.com/abo-abo/ace-window][ace-window]] to quickly switch between windows using =C-x o= instead of the
default =other-window= command.

#+BEGIN_SRC emacs-lisp
(use-package ace-window
  :custom
  (aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
  (aw-dispatch-always nil)
  (aw-dispatch-alist
   '((?x aw-delete-window     "Delete Window")
	   (?S aw-swap-window       "Swap Windows")
	   (?m aw-maximize-window   "Maximize Window")
     (?M aw-move-window       "Move Window")
	   (?c aw-copy-window       "Copy Window")
	   (?= aw-split-window-fair "Split Fair Window")
	   (?- aw-split-window-vert "Split Vert Window")
	   (?| aw-split-window-horz "Split Horz Window")
	   (?? aw-show-dispatch-help)))
  :config
  (set-face-attribute 'aw-leading-char-face nil :weight 'bold)
  :bind
  ("C-x o" . ace-window))
#+END_SRC

*** Setup =C-c w= micro state                                       :hydra:
**** Functions
Define a function to [[https://gist.github.com/3402786][maximize window]].

#+BEGIN_SRC emacs-lisp
(defun fikovnik/maximize-window ()
  (interactive)
  (if (and (= 1 (length (window-list)))
           (assoc ?_ register-alist))
      (jump-to-register ?_)
    (progn
      (window-configuration-to-register ?_)
      (delete-other-windows))))
#+END_SRC

**** Hydra

#+BEGIN_SRC emacs-lisp
(defhydra hydra-window (:hint nil)
   "
   ^Select^    ^Split^           ^Switch^           ^Resize^      ^Misc^
  -----------------------------------------------------------------------
      _↑_      _-_: vertical     _b_uffer             ⇧         _u_ndo/_r_edo
    _←_   _→_    _|_: horizontal   _f_ind files       ⇦   ⇨       _a_ce-window
      _↓_      ^ ^               _s_wap               ⇩         _d_elete/ace-_D_elete
   ^ ^         ^ ^               _m_aximize/_B_alance
"
   ("<left>" windmove-left)
   ("<down>" windmove-down)
   ("<up>" windmove-up)
   ("<right>" windmove-right)
   ("S-<left>" shrink-window-horizontally)
   ("S-<down>" enlarge-window)
   ("S-<up>" shrink-window)
   ("S-<right>" enlarge-window-horizontally)
   ("b" ivy-switch-buffer :color blue)
   ("f" counsel-find-files :color blue)
   ("a" ace-window :color blue)
   ("|" (lambda ()
          (interactive)
          (split-window-right)
          (windmove-right)))
   ("-" (lambda ()
          (interactive)
          (split-window-below)
          (windmove-down)))
   ("s" (lambda ()
          (interactive)
          (ace-window 4)
          (add-hook 'ace-window-end-once-hook
                    'hydra-window/body)))
   ("d" kill-buffer-and-window :color blue)
   ("D" ace-delete-window)
   ("m" fikovnik/maximize-window :color blue)
   ("B" balance-windows-area)
   ("u" (progn
          (winner-undo)
          (setq this-command 'winner-undo)))
   ("r" winner-redo)
   ("q" nil :color blue))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(bind-key "C-c w" 'hydra-window/body)
#+END_SRC
*** TODO move windows (like spacemacs)
** Go to (=M-G=)
*** Setup Avy

This allows to quickly jump around in the buffer. The way it is setup is by
remapping the =M-g= to a hydra that calls various [[https://github.com/abo-abo/avy][avy]] functions.

#+BEGIN_SRC emacs-lisp
(global-unset-key (kbd "M-G"))
(global-unset-key (kbd "M-g"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun my-zap-to-char (pt)
  "Kill from point to PT."
  (if (> pt (point))
      (kill-region (point) (+ pt 1))
    (kill-region (- pt 1) (point))))

(use-package avy
  :bind
  ("M-G" . hydra-goto/body)
  ("M-g" . avy-goto-char)
  :config
  (add-to-list 'avy-dispatch-alist '(?Z . my-zap-to-char))
  (avy-setup-default)
  (set-face-attribute 'avy-lead-face-0 nil :foreground "black"))
#+END_SRC

*** Setup =M-G= micro state                                         :hydra:

#+BEGIN_SRC emacs-lisp
(defhydra hydra-goto (:hint nil :color blue)
  ("c" avy-goto-char "char" :column "Char")
  ("w" avy-goto-word-1 "word" :column "word")
  ("W" avy-goto-word-0 "Word")
  ("g" goto-line "line by number" :column "Line")
  ("l" avy-goto-line "line" :column "Line")
  ("L" avy-goto-end-of-line "line end")
  ("m" avy-move-line "move line" :column "Edit")
  ("M" avy-move-region "move region" :column "Edit")
  ("k" avy-kill-whole-line "kill line" :column "Edit")
  ("K" avy-kill-region "kill region" :column "Edit")
  ("y" avy-copy-line "copy line" :column "Edit")
  ("Y" avy-copy-region "copy region" :column "Edit")
  ("q" nil))
#+END_SRC

*** TODO next / previous error
*** TODO next / previous spelling problem
** Buffers (=C-c b=)
*** Functions

#+BEGIN_SRC emacs-lisp
(eval-and-compile
  (defun fikovnik/new-empty-buffer ()
    "Create a new buffer called untitled(<n>)."

    (interactive)
    (let ((newbuf (generate-new-buffer "untitled")))
      (with-current-buffer newbuf
        (setq-local buffer-offer-save t))
      (switch-to-buffer newbuf nil 'force-same-window)))

  (defun fikovnik/switch-to-messages-buffer (&optional arg)
    "Switch to the `*Messages*' buffer. If prefix argument ARG is
given, switch to it in an other, possibly new window."

    (interactive "P")
    (with-current-buffer (messages-buffer)
      (goto-char (point-max))
      (if arg
          (switch-to-buffer-other-window (current-buffer))
        (switch-to-buffer (current-buffer)))))

(defun fikovnik/switch-to-scratch-buffer (&optional arg)
  "Switch to the `*scratch*' buffer, creating it first if needed.
If prefix argument ARG is given, switch to it in an other,
possibly new window."

  (interactive "P")
  (let ((exists (get-buffer "*scratch*")))
    (if arg
        (switch-to-buffer-other-window (get-buffer-create "*scratch*"))
      (switch-to-buffer (get-buffer-create "*scratch*")))))

(defun fikovnik/kill-buffer-and-window ()
  (interactive)
  (if (> (count-windows) 1)
      (kill-buffer-and-window)
    (kill-buffer))))
#+END_SRC

*** Setup =C-c b= micro state                                       :hydra:

#+BEGIN_SRC emacs-lisp
(defhydra hydra-buffers (:exit t :hint nil)
  ("b" switch-buffer "list")
  ("n" next-buffer "next")
  ("p" previous-buffer "previous")
  ("k" kill-this-buffer "kill")
  ("x" fikovnik/kill-buffer-and-window "close")
  ("R" revert-buffer "revert")
  ("N" fikovnik/new-empty-buffer "new")
  ("m" fikovnik/switch-to-messages-buffer "switch to messages")
  ("s" fikovnik/switch-to-scratch-buffer "switch to scratch")
  ("i" ibuffer "ibuffer"))
#+END_SRC

*** Binding

#+BEGIN_SRC emacs-lisp
(bind-key "C-c b" 'hydra-buffers/body)
(bind-key "C-x C-k" 'fikovnik/kill-buffer-and-window)
#+END_SRC

** TODO pgup/pgdown go to the same location
** TODO Go to matching paren
** TODO Gentle navigation
** Highlight symbols (=M-*=)

#+BEGIN_SRC emacs-lisp
(defun fikovnik/swiper-at-point (initial-input)
  (interactive (list (thing-at-point 'symbol)))
  (swiper initial-input))

(bind-key "M-*" 'fikovnik/swiper-at-point)
#+END_SRC

** TODO move to previous/next edit location

#+BEGIN_SRC emacs-lisp :tangle no
(use-package goto-chg
  :commands goto-last-change
  ;; complementary to
  ;; C-x r m / C-x r l
  ;; and C-<space> C-<space> / C-u C-<space>
  :bind (("C-." . goto-last-change)
         ("C-," . goto-last-change-reverse)))
#+END_SRC

** TODO ace-link
- https://github.com/abo-abo/ace-link
** =C-a= / =home= to the beginning

#+BEGIN_SRC emacs-lisp
(bind-key "C-a" #'crux-move-beginning-of-line)
(bind-key "<home>" #'crux-move-beginning-of-line)
#+END_SRC

*** TODO text objects
- https://github.com/clemera/objed
** Bookmarks

| Key       | Description            | Function                  |
|-----------+------------------------+---------------------------|
| =C-x r l= | List bookmarks         | =bookmark-list=           |
| =C-x r b= | Jump to a bookmark     | =bookmark-jump=           |
| =C-x r m= | Set bookmark           | =bookmark-set=            |

#+BEGIN_SRC emacs-lisp
(use-package bookmark
  :custom
  (bookmark-default-file (expand-file-name "bookmarks" fikovnik/savefile-dir))
  (bookmark-save-flag 1))
#+END_SRC
** TODO popup global mark
** TODO go to the last definition
* Search and replace
** Replace

#+BEGIN_SRC emacs-lisp
(use-package anzu
  :defer 1
  :diminish
  :bind
  ([remap query-replace] . anzu-query-replace)
  ([remap query-replace-regexp] . anzu-query-replace-regexp)
  :custom
  (anzu-replace-to-string-separator " → ")
  :config
  (global-anzu-mode 1))
#+END_SRC

* Toggles (=C-c t=)
** Setup =C-c t= micro state                                         :hydra:

#+BEGIN_SRC emacs-lisp
(defhydra hydra-toggle (:color blue :hint nil)
  "
[_a_] abbrev-mode:       %`abbrev-mode
[_d_] debug-on-error:    %`debug-on-error
[_f_] auto-fill-mode:    %`auto-fill-function
[_t_] truncate-lines:    %`truncate-lines
[_w_] whitespace-mode:   %`whitespace-mode
[_l_] org link display:  %`org-descriptive-links
"
  ("a" abbrev-mode)
  ("d" toggle-debug-on-error)
  ("f" auto-fill-mode)
  ("t" toggle-truncate-lines)
  ("w" whitespace-mode)
  ("l" org-toggle-link-display)
  ("q" nil "quit"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(bind-key "C-c t" 'hydra-toggle/body)
#+END_SRC

* TODO Mouse
* Projects
** Projectile configuration (=C-c p=)

#+BEGIN_SRC emacs-lisp
(use-package projectile
  :defer 1
  :diminish "P"
  :bind-keymap
  ("C-c p" . projectile-command-map)
  :bind
  ("C-c /" . fikovnik/search-in-project-or-dir-empty)
  (:map projectile-command-map
        ("C-k" . fikovnik/kill-non-project-buffers)
        ("/" . fikovnik/search-in-project-or-dir-empty))
  :custom
  (projectile-indexing-method 'alien)
  (projectile-completion-system 'ivy)
  (projectile-project-search-path fikovnik/projects-search-path)
  ;; enable caching otherwise it will be slow for large projects
  (projectile-enable-caching t)
  (projectile-generic-command "fd . -0")
  (projectile-git-command "fd . -0")
  (projectile-sort-order 'recently-active)
  :config
  ;; https://github.com/purcell/emacs.d/blob/4e487d4ef2ab39875d96fd413fca3b075faf9612/lisp/init-ivy.el#L49
  (defun fikovnik/search-in-project-or-dir (initial-input &optional use-current-dir)
    "Search using `counsel-rg' from the project root for INITIAL-INPUT.
     If there is no project root, or if the prefix argument
     USE-CURRENT-DIR is set, then search from the current
     directory instead. With multiple prefix arguments, or a
     numeric prefix argument go up multiple parent directories."

    (interactive (list (thing-at-point 'symbol)
                       current-prefix-arg))

    (let ((current-prefix-arg)
          (ignored (mapconcat (lambda (i)
                                (concat "--glob "
                                        (shell-quote-argument (concat "!" i))
                                        " "))
                              (append (projectile-ignored-files-rel)
                                      (projectile-ignored-directories-rel))
                              ""))
          (dir (cond
                ((equal use-current-dir nil) ; no prefix: use project root
                 (condition-case _err
                     (projectile-project-root)
                   (error default-directory)))
                ((equal use-current-dir '(4)) ; C-u: use current dir
                 (parent-directory default-directory 0))
                ((equal use-current-dir '(16)) ; C-u C-u: use parent dir
                 (parent-directory default-directory 1))
                ((equal use-current-dir '(64)) ; C-u C-u C-u: go 2 up
                 (parent-directory default-directory 2))
                (t  ; Numeric prefix: Go specified prefix up
                 (parent-directory default-directory use-current-dir)))))
      (counsel-rg initial-input dir ignored (projectile-prepend-project-name "rg "))))

  (defun fikovnik/search-in-project-or-dir-empty (&optional use-current-dir)
    "Like fikovnik/search-in-project-or-dir with no initial input."
    (interactive "P")
    (fikovnik/search-in-project-or-dir "" use-current-dir))

  ;; http://emacs.stackexchange.com/a/10187/115
  (defun fikovnik/kill-non-project-buffers (&optional kill-special)
    "Kill buffers that do not belong to a `projectile' project.
With prefix argument, also kill the special buffers."
    (interactive "P")
    (let ((bufs (buffer-list (selected-frame))))
      (dolist (buf bufs)
        (with-current-buffer buf
          (let ((buf-name (buffer-name buf)))
            (when (or (null (projectile-project-p))
                      (and kill-special
                           (string-match "^\*" buf-name)))
              ;; Preserve buffers with names starting with *scratch or *Messages
              (unless (string-match "^\\*\\(\\scratch\\|Messages\\)" buf-name)
                (message "Killing buffer %s" buf-name)
                (kill-buffer buf))))))))

  (projectile-mode))
#+END_SRC

It is good to run the

#+BEGIN_SRC emacs-lisp
(projectile-discover-projects-in-search-path)
#+END_SRC

to index the projects in the search path.

*** Counsel integration

#+BEGIN_SRC emacs-lisp
(use-package counsel-projectile
  :after (projectile counsel)
  :config
  (counsel-projectile-mode))
#+END_SRC

*** Notes

Ivy's call is like helm's follow-mode.

* Packages
** TODO this section should be removed and the packages moved accrodingly
** ibuffers

#+BEGIN_SRC emacs-lisp
(use-package ibuffer
  :bind
  ([remap list-buffers] . ibuffer))
#+END_SRC

**** TODO hydra
- https://github.com/abo-abo/hydra#the-impressive-looking-one
** which-key

#+BEGIN_SRC emacs-lisp
(use-package which-key
  :demand t
  :diminish
  :custom
  (which-key-idle-delay 0.3)
  :config
  (which-key-mode))
#+END_SRC

** dired
*** Settings

Auto refresh dired
#+BEGIN_SRC emacs-lisp
(add-hook 'dired-mode-hook 'auto-revert-mode)
(setq
      global-auto-revert-non-file-buffers t
      auto-revert-verbose                 nil
      ;; file sizes in human-readable units (KB, MB, etc)
      dired-listing-switches              "-alh"
)
#+END_SRC
*** TODO double pane setup
https://github.com/jwiegley/dot-emacs/blob/master/init.el#L1027
*** TODO dired toggle
https://github.com/jwiegley/dot-emacs/blob/master/init.el#L1162
*** TODO diredx
https://github.com/jwiegley/dot-emacs/blob/master/init.el#L1172
*** TODO hydra
** info
*** TODO hydra
** diff

#+BEGIN_SRC emacs-lisp
(use-package ediff
  :config
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
  (setq-default ediff-highlight-all-diffs 'nil)
  (setq ediff-diff-options "-w"))
#+END_SRC

*** TODO keybinding
https://github.com/jwiegley/dot-emacs/blob/master/init.el#L1268

** TODO kbd macros
** View large files
#+BEGIN_SRC emacs-lisp
(use-package vlf
  :custom
  (large-file-warning-threshold (* 64 1024 1024))
  :ensure t
  :config
  (require 'vlf-setup))
#+END_SRC

* Helpers
** config.org and init.el helpers

#+BEGIN_SRC emacs-lisp
(use-package iqa
  :custom
  (iqa-user-init-file (emacs-path "config.org"))
  :bind (:prefix "C-c e"
         :prefix-map my-emacs-helper-map
         :prefix-docstring "Emacs init.el related"
         ("e" . iqa-find-user-init-file)
         ("r" . iqa-reload-user-init-file)
         ("d" . iqa-find-user-init-directory)
         ("g" . fikovnik/dotfiles-magit)
         ("s" . fikovnik/sync-configuration)
         ("c" . fikovnik/sync-configuration-and-compile))
  :init
  (which-key-add-key-based-replacements "C-c e" "Emacs")
  (which-key-add-key-based-replacements "C-c e c" "sync & compile")
  (which-key-add-key-based-replacements "C-c e s" "sync")
  (which-key-add-key-based-replacements "C-c e g" "magit")
  (which-key-add-key-based-replacements "C-c e r" "reload config"))
#+END_SRC

** Life cycle

#+BEGIN_SRC emacs-lisp
(use-package restart-emacs
  :init
  (defun fikovnik/sync-configuration-and-restart ()
    (interactive)
    (fikovnik/sync-configuration nil)
    (restart-emacs))

  (defun fikovnik/restart-emacs-with-debug ()
    (interactive)
    (restart-emacs '("--debug-init")))

  (which-key-add-key-based-replacements "C-c e R" "restart Emacs")
  (which-key-add-key-based-replacements "C-c e D" "restart Emacs with debug")
  (which-key-add-key-based-replacements "C-c e S" "sync & restart Emacs")
  :commands restart-emacs
  :bind (:map my-emacs-helper-map
              ("R" . restart-emacs)
              ("D" . fikovnik/restart-emacs-with-debug)
              ("S" . fikovnik/sync-configuration-and-restart)))
#+END_SRC

* Version control
** Sort buffers in ibuffer based on git

#+BEGIN_SRC emacs-lisp
(use-package ibuffer-vc
  :hook
  (ibuffer . (lambda ()
               (ibuffer-vc-set-filter-groups-by-vc-root)
               (unless (eq ibuffer-sorting-mode 'alphabetic)
                 (ibuffer-do-sort-by-alphabetic)))))
#+END_SRC

** Magit

#+BEGIN_SRC emacs-lisp
(use-package magit
  :custom
  (magit-display-buffer-function 'magit-display-buffer-fullframe-status-v1 "Enable fullscreen")
  (magit-completing-read-function 'ivy-completing-read)
  :bind
  ("C-c g" . magit-status))
#+END_SRC

** Highlight chnages in files

#+BEGIN_SRC emacs-lisp
(use-package diff-hl
  :hook
  ((prog-mode . diff-hl-mode)
   (prog-mode . diff-hl-margin-mode)
   (org-mode . diff-hl-mode)
   (org-mode . diff-hl-margin-mode)
   (dired-mode . diff-hl-dired-mode))
  :config
  (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh))
#+END_SRC

** Support for my local dot-file config

I use git to version my dot files. While there are many options for managing
them such as [[https://github.com/RichiH/vcsh][vcsh]], I prefer the simplest possible, just using git and nothing
else. The trick is to separate work tree and git directory. While this work
well, magit does not understand this and has to have the relevant =--work-tree=
and =--git-dir= options explicitly set. For this I define a new function
=fikovnik/dotfiles-magit= which tries to do that.

#+BEGIN_SRC emacs-lisp
(defconst fikovnik/dotfiles-git-dir (expand-file-name "~/.dotfiles"))

(defun fikovnik/-dotfiles-remove-magit-config (&optional kill)
  (setq magit-git-global-arguments
        (remove (format "--work-tree=%s" (getenv "HOME")) magit-git-global-arguments))
  (setq magit-git-global-arguments
        (remove (format "--git-dir=%s" fikovnik/dotfiles-git-dir) magit-git-global-arguments))
  (advice-remove 'magit-mode-bury-buffer #'fikovnik/-dotfiles-remove-magit-config))

(defun fikovnik/dotfiles-magit ()
  (interactive)
  (when (and (boundp 'magit-git-global-arguments)
             (file-exists-p fikovnik/dotfiles-git-dir))
    (let ((home (getenv "HOME")))
      (add-to-list 'magit-git-global-arguments
                   (format "--work-tree=%s" home))
      (add-to-list 'magit-git-global-arguments
                   (format "--git-dir=%s" fikovnik/dotfiles-git-dir))
      (advice-add 'magit-mode-bury-buffer :after #'fikovnik/-dotfiles-remove-magit-config)
      (magit-status-setup-buffer home))))
#+END_SRC
*** TODO allow the =dotfiles-magit= work even if magit have not been initialized yet
** TODO magit-todo

* Org
** Default setup

#+BEGIN_SRC emacs-lisp
(use-package org
  :demand t
  ;; to be sure we have the latest Org version
  :ensure org-plus-contrib
  :mode
  ("\\.org$" . org-mode)
  :hook
  (org-mode . flyspell-mode)
  :custom
  (org-catch-invisible-edits 'smart)
  (org-src-tab-acts-natively t)
  (org-src-preserve-indentation t)
  (org-confirm-babel-evaluate nil)
  (org-log-done t)
  (org-startup-with-inline-images t)
  (org-latex-prefer-user-labels t)
  (org-image-actual-width nil)
  (org-id-link-to-org-use-id 'create-if-interactive)
  (org-agenda-files '("~/Notes/Journal"))
  (org-directory "~/Notes")
  (org-default-notes-file "~/Notes/Journal/Notes.org")
  (org-startup-indented 1)
  (org-blank-before-new-entry '(((heading .  t) (plain-list-item . t))))
  (org-log-reschedule 'time)
  (org-log-into-drawer t)
  (org-refile-targets (quote ((nil :maxlevel . 9) (org-agenda-files :maxlevel . 9))))
  (org-refile-allow-creating-parent-nodes t)
  (org-refile-use-outline-path t)
  (org-src-fontify-natively t)
  (org-imenu-depth 8)
  (org-todo-keywords '((sequence "TODO(t)" "WAIT(w@/!)" "|" "DONE(d!)" "CANCELED(c@)")))
  (org-capture-templates
     '(("t" "Todo"         entry (file+headline "~/Notes/Journal/TODO.org" "INBOX")  "* TODO %?\ncaptured on: %U\nfrom: %a\n%i")
       ("n" "Note"         entry (file+headline "~/Notes/Journal/Notes.org" "Notes") "* %?\ncaptured on: %U\nfrom: %a\n%i")
       ("j" "Journal"      entry (file+datetree "~/Notes/Journal/Journal.org")    "* %?\n%i")
       ("J" "Work Journal" entry (file+datetree "~/Notes/Journal/Work.org")  "* %?\n%i")))
  :bind
  ("C-c c" . org-capture))
#+END_SRC

** Better appearance

#+BEGIN_SRC emacs-lisp
(use-package org-bullets
  :custom
  (org-bullets-bullet-list '("•"))
  (org-ellipsis "↴")
  :hook
  (org-mode . org-bullets-mode))
#+END_SRC

** Yasnippet support

From [[https://orgmode.org/worg/org-faq.html#YASnippet][org-manual]]:
#+begin_quote
The way Org-mode binds the TAB key (binding to [tab] instead of \t) overrules yasnippets' access to this key.
#+end_quote

The following is the _official_ way to fix it:

#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook
          (lambda ()
            (make-variable-buffer-local 'yas/trigger-key)
            (setq yas/trigger-key [tab])
            (add-to-list 'org-tab-first-hook 'yas-expand)
            (define-key yas-keymap [tab] 'yas-next-field)))
#+END_SRC

** Babel

#+BEGIN_SRC emacs-lisp
(use-package ob
  :ensure org-plus-contrib
  :after org
  :commands org-babel-load-languages
  :custom
  (org-babel-load-languages
   '((shell . t)
     (emacs-lisp . t)))
  :config
  (defun fikovnik/-org-babel-do-load-languages ()
    "Load all the languages declared in `org-babel-load-languages'."
    (org-babel-do-load-languages 'org-babel-load-languages
                                 org-babel-load-languages))

  (defun org-babel-remove-result-buffer ()
    "Remove results from every code block in buffer."
    (interactive)
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward org-babel-src-block-regexp nil t)
        (org-babel-remove-result))))

  (add-hook 'org-mode-hook 'fikovnik/-org-babel-do-load-languages))
#+END_SRC

*** TODO Fix redisplay of inline images after a code block evaluation.

#+BEGIN_SRC emacs-lisp :tangle no
(add-hook 'org-babel-after-execute-hook 'spacemacs/ob-fix-inline-images)
#+END_SRC
** TODO org-ref
** TODO images
- https://github.com/abo-abo/org-download
** TODO [[https://github.com/alphapapa/org-sticky-header][org-sticky-header]]
** TODO [[https://github.com/bastibe/org-journal][org-journal]]
** TODO org-projectile
** TODO org-present ?
** TODO better refiling
** TODO lazy load
* Languages
** General
*** TODO configure flymake
*** TODO install dash
*** Documentation with eldoc

#+BEGIN_SRC emacs-lisp
(use-package eldoc
  :ensure nil
  :diminish (eldoc-mode . "ELD")
  :commands eldoc-mode)
#+END_SRC

*** Enable LSP

#+BEGIN_SRC emacs-lisp
(use-package lsp-mode
  :custom
  (lsp-prefer-flymake t)
  :commands lsp)

(use-package lsp-ui
  :custom
  (lsp-ui-sideline-enable nil)
  :commands lsp-ui-mode)

(use-package company-lsp
  :custom
  (company-transformers nil)
  (company-lsp-async t)
  (company-lsp-cache-candidates nil)
  :commands company-lsp)
#+END_SRC

| Key     | Description      | Function                |
|---------+------------------+-------------------------|
| =M-.=   | Find definitions | =xref-find-definitions= |
| =M-?=   | Find references  | =xref-find-references=  |
| =C-M-.= |                  | =xref-find-apropos=     |

*** TODO move to eglot
*** TODO realgud
*** Interpreters
**** Create termino for comint with support for ANSI color codes

#+BEGIN_SRC sh :tangle no
cat > /tmp/dumb-emacs-ansi.ti << EOF
dumb-emacs-ansi|Emacs dumb terminal with ANSI color codes,
    am,
    colors#8, it#8, ncv#13, pairs#64,
    bold=\E[1m, cud1=^J, ht=^I, ind=^J, op=\E[39;49m,
    ritm=\E[23m, rmul=\E[24m, setab=\E[4%p1%dm,
    setaf=\E[3%p1%dm, sgr0=\E[m, sitm=\E[3m, smul=\E[4m,
EOF

tic -x /tmp/dumb-emacs-ansi.ti
rm /tmp/dumb-emacs-ansi.ti
#+END_SRC

**** Make the interpreter work like an interpreter

#+BEGIN_SRC emacs-lisp
(use-package comint
  :defer 2
  :ensure nil
  :bind (:map comint-mode-map
              ([up] . comint-previous-matching-input-from-input)
              ([down] . comint-next-matching-input-from-input)
              ("C-k" . kill-line))
  :custom
  (comint-buffer-maximum-size 8192)
  (comint-terminfo-terminal "dumb-emacs-ansi")
  (comint-scroll-to-bottom-on-output 'others)
  (comint-scroll-show-maximum-output t)
  (comint-move-point-for-matching-input 'end-of-line)
  (comint-scroll-to-bottom-on-input 'this))
#+END_SRC

*** Compilation

#+BEGIN_SRC emacs-lisp
(use-package compile
  :custom
  ;; always save before compiling
  (compilation-ask-about-save nil)
  ;; just kill old compile processes before starting the new one
  (compilation-always-kill t)
  ;; scroll with the compilation output
  ;; set to 'first-error to stop scrolling on first error
  (compilation-scroll-output t))
#+END_SRC

** C/C++
*** Backend

Use [[https://github.com/MaskRay/ccls/wiki/lsp-mode][ccls]] as the backend for C/C++.

#+BEGIN_SRC emacs-lisp
(use-package ccls
  :custom
  (ccls-initialization-options '(:index (:comments 2) :completion (:detailedLabel t)))
  ;; no semantic highlighting
  (ccls-sem-highlight-method nil)
  :hook
  ((c-mode c++-mode objc-mode) . (lambda () (require 'ccls) (lsp))))
#+END_SRC

Not sure why it is needed, but without I get =lsp--location-to-td-position:
Wrong type argument: hash-table-p, nil=, cf. [[https://github.com/MaskRay/emacs-ccls/issues/17][emacs-ccls:#17]]

#+BEGIN_SRC emacs-lisp
(setq xref-prompt-for-identifier
      '(not xref-find-definitions
            xref-find-definitions-other-window
            xref-find-definitions-other-frame
            xref-find-references))
#+END_SRC

*** TODO Semantic movement

Bind these to some keys?

#+BEGIN_SRC emacs-lisp :tangle no
(ccls-navigate "D") ;; roughly sp-down-sexp
(ccls-navigate "L")
(ccls-navigate "R")
(ccls-navigate "U")
#+END_SRC

*** TODO C++ hierarchy
ccls-member-hierarchy $ccls/member hierarchy:true

(ccls-call-hierarchy nil) ; caller hierarchy
(ccls-call-hierarchy t) ; callee hierarchy

$ccls/call

(ccls-inheritance-hierarchy nil) ; base hierarchy
(ccls-inheritance-hierarchy t) ; derived hierarchy
** TODO Elisp

We set up smartparens above, but when it’s enabled in strict mode for lisps it
really comes into its own. As a refresher, don’t forget about C-( and note that
thanks to universal arguments you can prefix a number which will wrap multiple
s-expressions. e.g. C-2 C-( on a b c will turn it into (a b) c.

It’s well worth studying sp-smartparens-bindings with C-h v to see what else is
enabled. M-<delete> is also incredibly useful.

#+BEGIN_SRC emacs-lisp :tangle no
(add-hook 'emacs-lisp-mode-hook
          (lambda ()
            (setq show-trailing-whitespace t)
            (show-paren-mode)
            (focus-mode)
            (rainbow-mode)
            (prettify-symbols-mode)
            (eldoc-mode)
            (flycheck-mode)
            (yas-minor-mode)
            (company-mode)
            (smartparens-strict-mode)
            (rainbow-delimiters-mode)))
#+END_SRC

** TODO scala
- using ensime?

#+BEGIN_SRC emacs-lisp :tangle no
(sp-local-pair 'scala-mode "(" nil :post-handlers '(("||\n[i]" "RET")))
(sp-local-pair 'scala-mode "{" nil :post-handlers '(("||\n[i]" "RET") ("| " "SPC")))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
(defun sp-restrict-c (sym)
  "Smartparens restriction on `SYM' for C-derived parenthesis."
  (sp-restrict-to-pairs-interactive "{([" sym))

(bind-key "s-<delete>" (sp-restrict-c 'sp-kill-sexp) scala-mode-map)
(bind-key "s-<backspace>" (sp-restrict-c 'sp-backward-kill-sexp) scala-mode-map)
(bind-key "s-<home>" (sp-restrict-c 'sp-beginning-of-sexp) scala-mode-map)
(bind-key "s-<end>" (sp-restrict-c 'sp-end-of-sexp) scala-mode-map)
#+END_SRC

Ever wanted to change a (_.thing) to a { foo => foo.thing } and back? This helps…

#+BEGIN_SRC emacs-lisp :tangle no
(bind-key "s-{" 'sp-rewrap-sexp smartparens-mode-map)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
(require 'ensime-expand-region)

(add-hook 'scala-mode-hook
          (lambda ()
            (show-paren-mode)
            (smartparens-mode)
            (yas-minor-mode)
            (git-gutter-mode)
            (company-mode)
            (ensime-mode)
            (scala-mode:goto-start-of-code)))

#+END_SRC

** R

#+BEGIN_SRC emacs-lisp
(use-package ess
  :mode (("/R/.*\\.q\\'"       . R-mode)
         ("\\.[rR]\\'"         . R-mode)
         ("\\.[rR]nw\\'"       . Rnw-mode)
         ("\\.[sS]nw\\'"       . Snw-mode)
         ("\\.[rR]profile\\'"  . R-mode)
         ("NAMESPACE\\'"       . R-mode)
         ("CITATION\\'"        . R-mode)
         ("\\.Rd\\'"           . Rd-mode))
  :commands R
  :hook (ess-mode . subword-mode)
  :custom
  (ess-default-style 'Rstudio)
  (ess-indent-level 4)
  (ess-nuke-trailing-whitespace-p t)
  (ess-tab-complete-in-script t)
  (ess-build-tags-command "system(\"~/bin/rtags.R '%s' '%s'\")")
  (ess-indent-with-fancy-comments nil)
  (ess-R-argument-suffix "=")
  (ess-smart-S-assign-key nil)
  (ess-R-font-lock-keywords '((ess-R-fl-keyword:fun-defs . t)
                              (ess-R-fl-keyword:modifiers . t)
                              (ess-R-fl-keyword:keywords . t)
                              (ess-R-fl-keyword:assign-ops . t)
                              (ess-R-fl-keyword:constants . t)
                              (ess-R-fl-keyword:F&T . t)
                              (ess-fl-keyword:fun-calls . t)
                              (ess-fl-keyword:numbers . t)
                              (ess-fl-keyword:operators)
                              (ess-fl-keyword:delimiters)
                              (ess-fl-keyword:=))))
#+END_SRC

*** TODO [[https://github.com/polymode/poly-R][poly-R]]
*** TODO poly-markdown
*** TODO poly-org

** TODO Latex
** Config

#+BEGIN_SRC emacs-lisp
(use-package conf-mode
  :mode ("mbsyncrc\\'" "msmtprc\\'" "\\.cnf\\'"
         "\\.ini\\.\\(tmpl\\|sample\\)\\'" "\\.service\\'"))
#+END_SRC

** CSV

#+BEGIN_SRC emacs-lisp
(use-package csv-mode
  :mode "\\.csv\\'"
  :custom
  (csv-separators '("," "	" ";" "|")))
#+END_SRC

** TOML

#+BEGIN_SRC emacs-lisp
(use-package toml-mode
  :mode ("\\.toml\\'" "Cargo.lock\\'"))
#+END_SRC

** YAML

#+BEGIN_SRC emacs-lisp
(use-package yaml-mode
  :mode ("\\.yaml\\'" "\\.yml\\'"))
#+END_SRC

** TODO Markdown
* Applications
** TODO agenda / calendar
** TODO email
** TODO elfeed
- https://github.com/abo-abo/elfeed
* Appearance
** Theme

#+BEGIN_SRC emacs-lisp
(use-package base16-theme
  :demand t
  :config
  (load-theme 'base16-oceanicnext t))
#+END_SRC

*** TODO better contrast between hl-line and region
** Font

TODO: font size hydra

#+BEGIN_SRC emacs-lisp
(add-to-list 'default-frame-alist
  (cond
    ((string-equal system-type "darwin")    '(font . "dejavu sans mono"))
    ((string-equal system-type "gnu/linux") '(font . "dejavu sans mono"))))
#+END_SRC

** Modeline
*** TODO better modeline?
- if so look at [[https://github.com/seagle0128/doom-modeline][doom-modeline]]
#+BEGIN_SRC emacs-lisp :tangle no
(use-package doom-modeline
  :demand t
  :config
  (add-hook 'after-init-hook #'doom-modeline-init)
  :custom
  (doom-modeline-major-mode-icon t)
  (doom-modeline-buffer-file-name-style 'buffer-name)
  (doom-modeline-icon t))
#+END_SRC
** Cursor
*** TODO bar cursor
** Colors
*** Cursor color
**** Functions

- TODO: defvar for shape and color at the beginning

#+BEGIN_SRC emacs-lisp
(defconst fikovnik/cursor-types '((box-blink  . 1)
                                  (box        . 2)
                                  (hbar-blink . 3)
                                  (hbar       . 4)
                                  (bar-blink  . 5)
                                  (bar        . 6))
  "Available cursor types as tuple of name and terminal code")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun fikovnik/-tmux-p ()
  "Running in tmux."
  (getenv "TMUX"))

(defun fikovnik/-make-tmux-seq (seq)
  (format "\ePtmux;\e%s\e\\" seq))

(defun fikovnik/-cursor-shape-seq (shape)
  "Make escape sequence for XTerm compatible terminals."
  (let* ((cursor-code (cdr (assoc shape fikovnik/cursor-types)))
         (seq (format "\e[%d q" cursor-code)))
    (if (fikovnik/-tmux-p)
        (fikovnik/-make-tmux-seq seq)
      seq)))

(defun fikovnik/set-cursor-shape (shape)
  (let ((seq (fikovnik/-cursor-shape-seq shape)))
    (message "%s" seq)
    (send-string-to-terminal seq)))

(defun fikovnik/-cursor-color-seq (color)
  "Make escape sequence for cursor color (in HEX)."
  (let ((seq (format "\e]12;%s\a" color)))
    (if (fikovnik/-tmux-p)
        (fikovnik/-make-tmux-seq seq)
      seq)))

(defun fikovnik/set-cursor-color (color)
  (let ((seq (fikovnik/-cursor-color-seq color)))
    (message "%s" seq)
    (send-string-to-terminal seq)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(set-cursor-color "#ee30a7")
(setq-default cursor-type 'bar)
#+END_SRC
**** TODO cursor color in GUI

*** Region color

#+BEGIN_SRC emacs-lisp
(set-face-attribute 'region nil :foreground "#000000" :background "#cd6090")
#+END_SRC

**** TODO sync with tmux region color 30;45 ideally

*** Fix org colors

#+BEGIN_SRC emacs-lisp
(eval-after-load "org"
  (lambda () (progn
               (set-face-attribute 'org-todo nil :weight 'bold))))
#+END_SRC
* Troubleshooting
** Invalid function =org-preserve-local-variables=

As indicated in [[https://github.com/syl20bnr/spacemacs/issues/11801#issuecomment-451755821][spacemacs/11801]], the problem is in version misalignment which
can be fixed by removing all =org-*/*.elc= files and compiling it again:

#+BEGIN_SRC sh :tangle no
find ~/.emacs.d/elpa/org*/*.elc -print0 | xargs -0 rm
#+END_SRC

And then running the following function

#+BEGIN_SRC emacs-lisp :tangle no
(fikovnik/recompile-elpa)
#+END_SRC

** Invalid function =org-outline-overlay-data=

Similar to the above, this time caused by expand region [[https://github.com/syl20bnr/spacemacs/issues/12099][spacemacs/12099]].

#+BEGIN_SRC sh
find ~/.emacs.d/elpa/expand-region*/*.elc -print0 | xargs -0 rm
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
(fikovnik/recompile-elpa)
#+END_SRC


** Unable to install a package

In the case a package installation from =(use-package)= fails due to a missing
file on MELPA, it might be due to an outdated local index. Use:

#+BEGIN_SRC emacs-lisp :tangle no
(package-refresh-contents)
#+END_SRC
