#+TITLE: Emacs configuration file
#+AUTHOR: Filip Krikava
#+PROPERTY: header-args :comments link :results silent :eval yes

* Overview
** Requirements
- fzf
- rg
- fd
** Key bindings
*** Emacs conventions

Emacs defines a a few [[https://www.gnu.org/software/emacs/manual/html%5Fnode/elisp/Key-Binding-Conventions.html][key binding conversions]]:
- =C-x= sequences are for Emacs commands
- =C-c C-key= sequences are for major modes
- =C-c {,},<,>,:,;= sequences are for major modes
- =C-c key= and =<F5>-<F9>= are for users
- =C-c <ASCII punctuations / symbols>= sequences are for minor modes
- Don't bind =C-h= following any prefix character (including =C-c=)
- Don't bind a key sequence ending in =<ESC>= except following another =<ESC>=
- Don't bind a key sequence ending in =C-g=

*** Overview of the main key bindings

| Key         | Micro state                            |
|-------------+----------------------------------------|
| =C-c w=     | Windows prefix                         |
| =C-c b=     | Buffers prefix                         |
| =C-c t=     | Toggles prefix                         |
| =C-c p=     | Projects prefix                        |
| =C-c s=     | Snippets prefix                        |
| =C-c e=     | Emacs configuration prefix             |
| =C-c c=     | Org capture                            |
| =C-c d=     | Dired                                  |
| =C-c g=     | Magit prefix                           |
| =M-S-g=     | Go to prefix                           |
| =C-==       | Expand region prefix                   |
| =C-c /=     | Search in project or current directory |
| =M-'=       | Correct word                           |
| =M-;=       | Comment or uncomment                   |
| =M-i=       | imenu                                  |
| =M-I=       | imenu anywhere                         |
| =C-x C-k=   | Kill current buffer                    |
| =C-x C-S-k= | Kill current buffer and its window     |
| =C-x S-k=   | Kill current buffer and its window     |
| =C-x C-b=   | Switch buffer                          |
| =C-x o=     | Switch window                          |
| =M-*=       | Search for a symbol with swiper        |
| =C-x f=     | Find file using fzf                    |
| =M-g=       | Go to char in line                     |
| =M-u M-g=   | Go to char                             |

** Rename variables and functions (fikovnik -> my-)
** Remove the =init.el= from index tracking

#+BEGIN_SRC sh :tangle no
config update-index --assume-unchanged ~/.emacs.d/init.el
#+END_SRC
** TODO describe the idea behind this configuration
** TODO Show matching function
https://with-emacs.com/posts/editing/show-matching-lines-when-parentheses-go-off-screen/
** TODO use =:preable= for functions
** TODO use =(executable-find)=
** TODO use =:custom-face= to set faces
** TODO use straight.el
** TODO Fix adding new line after { in R mode
** TODO Use emacs as less pages
** TODO polymode
** TODO switch buffer only for the project
** TODO company in org mode and abbrev
** TODO better ivy keys
- [ ] mode arrow to enter / exit
- [ ] ivy tab to show actions
** TODO better window management
- [ ] use shackle instead of popwin
- [ ] position R
** TODO better color scheme
- [ ] 24bit support
- [ ] hl-line
- [ ] line indicating current line in R debugger session
- [ ] org todo keywords
- [ ] region
- [ ] iedit highling
- [ ] modeline of active / inactive window
- [ ] org-outline-4 which inherits from outline-4 which inherits from font-lock-comment-face
- [ ] comments are dark and this makes it ugly
- [ ] org-verbatim is also too dark
** TODO in org-mode set the C-A to move at the beginning of the heading if at heading
- currently it only moves to the beginning of the line - in front of all the stars
** TODO in hippie expand / abbrev is it possible to add suggestion based on spelling
* Sources
** TODO clean and describe
*** TODO https://github.com/yiufung/dot-emacs/blob/master/init.el
- pure init.el
*** TODO https://shrysr.github.io/docs/sr-config/
  - based scimax
*** TODO https://github.com/angrybacon/dotemacs/blob/master/dotemacs.org
*** TODO https://karl-voit.at/2017/06/03/emacs-org/
*** TODO https://writequit.org/org/
*** TODO http://doc.norang.ca/org-mode.html
*** Visited
- [[https://github.com/hlissner/doom-emacs/blob/develop/][Doom Emacs]]
- https://github.com/dakra/dmacs/blob/master/init.org
  - [[https://github.com/dakra/dmacs/blob/master/init.org#dired][dired]]
  - [[https://github.com/dakra/dmacs/blob/master/init.org#email][email]]
- [[https://github.com/jwiegley/dot-emacs/blob/master/init.el][John Wiegley’s config -- use-package author]]
- [[https://github.com/seagle0128/.emacs.d][Centaur emacs]]
  - look into https://github.com/seagle0128/.emacs.d/blob/master/lisp/init-basic.el
- [[https://ensime.github.io/editors/emacs/hacks/][Emacs hacks from Ensime folks]]
  - Coding in Lisp and Scala
- [[https://github.com/technomancy/better-defaults/blob/master/better-defaults.el][better-defaults.el]]
- [[http://www.emacs-bootstrap.com/][Emacs Bootstrap]]
- https://github.com/a13/emacs.d/blob/master/README.org
- https://github.com/freetonik/emacs-dotfiles/blob/master/init.org
  - emacs podcast guy configuration
- http://pages.sachachua.com/.emacs.d/Sacha.html
  - the emacs girl configuration
- https://github.com/danielmai/.emacs.d/blob/master/config.org
- https://thb.lt/emacs-cheatsheet/
- https://github.com/abo-abo/awesome-emacs
- https://github.com/redguardtoo/emacs.d
- https://github.com/abo-abo/oremacs
- https://github.com/purcell/emacs.d
- https://github.com/trending/emacs-lisp?since=monthly
- https://melpa.org/#/?sort=downloads&asc=false
- https://github.com/sam217pa/emacs-config/blob/develop/init.el
- https://sam217pa.github.io/2016/10/18/context-dependent-keybindings/
- http://www.matskjesrud.com/emacs.html
- https://old.reddit.com/r/emacs/comments/bk9k7l/tips_and_tricks_for_r_programming_in_academia/
  - about R
- http://juanjose.garciaripoll.com/blog/emacs-wanderlust-email
  - about wunderlust
[[https://github.com/jwiegley/use-package][use-package]]
** To check
https://github.com/milkypostman/powerline
https://github.com/Fuco1/smartparens
* Preamble
** Lexical scoping

I like lexical scoping.

#+BEGIN_SRC emacs-lisp
;;; -*- lexical-binding: t -*-
#+END_SRC

* Startup
** Speed up startup

A few _optimization_ for a faster startup and perhaps a snappier behavior based
on [[https://github.com/jwiegley/dot-emacs/blob/master/init.el#L7][John Wiegley’s config]] and [[https://github.com/hlissner/doom-emacs/blob/develop/early-init.el][Doom Emacs's early-init.el]].

*** Set GC normal and deferred limits

#+BEGIN_SRC emacs-lisp
(defvar my-gc-cons-threshold (* 16 1024 1024)
  "The default value to use for `gc-cons-threshold'. If you experience freezing,
decrease this. If you experience stuttering, increase this.")

(defvar my-gc-cons-upper-limit (* 512 1024 1024)
  "The temporary value for `gc-cons-threshold' to defer it.")
#+END_SRC

*** Prevent the glimpse of un-styled Emacs by setting these early

#+BEGIN_SRC emacs-lisp
(if (fboundp 'menu-bar-mode)
    (menu-bar-mode -1))
(if (fboundp 'tool-bar-mode)
    (tool-bar-mode -1))
(if (fboundp 'scroll-bar-mode)
    (scroll-bar-mode -1))
(if (fboundp 'horizontal-scroll-bar-mode)
    (horizontal-scroll-bar-mode -1))
#+END_SRC

*** Do not run site file

One less file to load at startup

#+BEGIN_SRC emacs-lisp
(setq site-run-file nil)
#+END_SRC

*** Temporarily disable file name handlers

The =filen-name-handler-alist= is consulted on every `require', `load' and
various path/io functions. One might get a minor speed up by nooping this.

#+BEGIN_SRC emacs-lisp
(defvar my--file-name-handler-alist file-name-handler-alist)
(setq file-name-handler-alist nil)
#+END_SRC

*** Longer message log

#+BEGIN_SRC emacs-lisp
(setq message-log-max 16384)
#+END_SRC

*** Restore startup optimizations

Finally, we need to restore the startup optimizations to their defaults in
order to prevent stuttering/freezes.

#+BEGIN_SRC emacs-lisp
(defun my--restore-startup-optimizations ()
  "Resets garbage collection settings to reasonable defaults (a large
`gc-cons-threshold' can cause random freezes otherwise) and resets
`file-name-handler-alist'."

  (setq file-name-handler-alist my--file-name-handler-alist)

  ;; Do this on idle timer to defer a possible GC pause that could result; also
  ;; allows deferred packages to take advantage of these optimizations.
  (run-with-idle-timer
   3 nil
   (lambda ()
     (setq-default gc-cons-threshold my-gc-cons-threshold)

     ;; To speed up minibuffer commands (like helm and ivy), we defer garbage
     ;; collection while the minibuffer is active.
     (defun my--defer-garbage-collection ()
       (setq gc-cons-threshold my-gc-cons-upper-limit))
     (defun my--restore-garbage-collection ()
       ;; Defer it so that commands launched from the minibuffer can enjoy the
       ;; benefits.
       (run-at-time 1 nil (lambda () (setq gc-cons-threshold my-gc-cons-threshold))))

     (add-hook 'minibuffer-setup-hook #'my--defer-garbage-collection)
     (add-hook 'minibuffer-exit-hook  #'my--restore-garbage-collection)
     (add-hook 'focus-out-hook #'garbage-collect)))

  (message "Loaded in %.3fs"
           (float-time (time-subtract (current-time) emacs-start-time))))

(add-hook 'after-init-hook #'my--restore-startup-optimizations nil t)
#+END_SRC

** Common functions

#+BEGIN_SRC emacs-lisp
(eval-and-compile
  (defun my-recompile-elpa ()
    "Recompile packages in elpa directory"
    (interactive)
    (byte-recompile-directory package-user-dir 0 nil))

  (defun emacs-path (path)
    (expand-file-name path user-emacs-directory)))
#+END_SRC

** Turn off messages

#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-buffer-menu t)
(setq inhibit-startup-echo-area-message "krikava")
(setq inhibit-startup-message t)
(setq inhibit-startup-screen t)
(setq initial-scratch-message nil)
#+END_SRC

** Benchmark initialization

Who would not like to benchmark initialization of his text editor?

#+BEGIN_SRC emacs-lisp
(use-package benchmark-init
  :demand t
  :hook
  (after-init . benchmark-init/deactivate))
#+END_SRC

To see the results use either:

#+BEGIN_SRC emacs-lisp :tangle no
(benchmark-init/show-durations-tree)
#+END_SRC

or

#+BEGIN_SRC emacs-lisp :tangle no
benchmark-init/show-durations-tabulated
#+END_SRC

** Install diminish

Allow to use =:diminish= in =use-package= macro to diminish minor mode.

#+BEGIN_SRC emacs-lisp
;; :diminish keyword
(use-package diminish
  :demand t)
#+END_SRC

** Install bind-key

Allow to use =:bind-key= in =use-package= macro to easily bind-keys.

#+BEGIN_SRC emacs-lisp
;; :bind keyword
(use-package bind-key
  :demand t)
#+END_SRC

** Universal argument

It is super convenient to use =M-u= as the universal argument for =M-<key>=
commands.

#+BEGIN_SRC emacs-lisp
(bind-key "M-u" 'universal-argument)
#+END_SRC

* Defaults
** Global variables
*** Declarations
#+BEGIN_SRC emacs-lisp
(defconst my-config-file (emacs-path "config.org")
  "This Emacs's configuration file")

(defvar my-private-conf-dir (emacs-path "private")
  "Directory where to store my private config")

(defvar my-backup-dir (expand-file-name "backups" my-private-conf-dir)
  "Directory for backups")

(defvar my-auto-save-dir (expand-file-name "auto-saves" my-private-conf-dir)
  "Directory for auto save files")

(defvar my-snippets-dir (expand-file-name "snippets" my-private-conf-dir)
  "Directory for snippets")

(defvar my-keys nil
  "The list of keys to be mapped as pairs of keySym and ascii code")

(defvar my-keys-debug nil
  "Toggle my-keys debugging")

(defvar my-st-dir "~/Projects/st"
  "The location of st terminal sources")

(defvar my-projects-search-path '("~/Projects" "~/Research/Projects" "~/Research/Publications")
  "Paths where projects are stored. Used in projectile")

(defvar my-bibliography-path "~/Sync/Research/Resources/Papers"
  "Path where I keep papers")

(defvar my-bibliography-bib-file (expand-file-name "references.bib" my-bibliography-path)
  "The main bibliography bibtex file")

(defvar my-bibliography-notes-file (expand-file-name "notes.org" my-bibliography-path)
  "The main bibliography notes file")

(defvar my-dash-docsets '("C" "C++" "Emacs_Lisp" "Java_SE12" "R" "Rust" "Scala")
  "The DASH docsets to install")
#+END_SRC

** ST terminal
Treat st terminal as xterm (cf. https://www.gnu.org/software/emacs/manual/html_node/elisp/Terminal_002dSpecific.html)

#+BEGIN_SRC emacs-lisp
(add-to-list 'term-file-aliases (quote ("st" . "xterm")))
#+END_SRC

** Input map in terminal

This section fixes key bindings in Emacs running in a terminal.

*** Overview

There are several problems in handling key events in the current terminals. For
example:
- it is not possible to use modifiers other than =C-= and =M-=,
- the =C-= modifier encodes lower or upper-case letters identically,
- special names for some ASCII characters collide with =C-= modified letters (e.g., a tab is =C-i=),
- there is no reliable way to use multiple modifier keys, other than, =M-S-=,
- some keys cannot be used with =C-= modifier, eg., =;=, =.=, =/=.

The reason for all of this is that there is no standard for these _corner_
cases. There has been a several proposals:
- [[http://www.leonerd.org.uk/hacks/fixterms/][Paul Evan's fixterms]]
- [[https://sw.kovidgoyal.net/kitty/protocol-extensions.html#extensions-to-the-xterm-protocol][Kitty extension to xterm protocol]]
- [[https://github.com/CyberShadow/term-keys][term-keys package]]
- XTerm's [[https://invisible-island.net/xterm/manpage/xterm.html#VT100-Widget-Resources:formatOtherKeys][formatOtherKeys]] and [[https://invisible-island.net/xterm/manpage/xterm.html#VT100-Widget-Resources:modifyOtherKeys][modifyOtherKeys]] classes

I decided to use Paul's fixterm proposition (which is compatible with XTerm's
solution given =formatOtherKeys= is set to 1). It works as follows: for each
key combination that is not expressible in the current schema it will use the
following escape sequence:

#+BEGIN_SRC text :tangle no
ESC[<key>;<mod>u
#+END_SRC

where
- =key= is the ASCII decimal value of the key
- =mod= is 1 + bitmask encoding of the modifiers
  - =S-= = 1
  - =M-= = 2
  - =C-= = 4

For example, =C-;= sends =\e[59;5u=.

Xterm can do that as well with =formatOtherKeys:1=, which can be verified using:

#+BEGIN_SRC sh :tangle no
xterm -xrm '*modifyOtherKeys:1' -xrm '*formatOtherKeys:1' -e cat -v
#+END_SRC

- With =modifyOtherKeys:2= it can do even =C-m=, =C-j= and =C-i=:
  - =C-m= -- =109;5u=
  - =C-S-m= -- =77;6u=
  - =C-i= -- =105;5u=
  - =C-S-i= -- =73;6u=
  - =C-j= -- =106;5u=
  - =C-S-j= -- =74;5u=
  - =C-`= -- =96;5u=
  - =C-\= -- =92;5u=

For this to work, two things need to be updated:
1. the terminal emulator (st in my case)
2. the emacs's =input-decode-map=

**** Terminal - st

In [[https://st.suckless.org/][st]] (my terminal of choice), one has to modify two places:
1. =mappedkeys= variable in =config.h= which contains a list of
   custom-mapped keys:

   #+BEGIN_SRC c :tangle no
   XK_semicolon
   #+END_SRC

2. =keys= variable in =config.h= containing the actual mapping:

   #+BEGIN_SRC c :tangle no
   {XK_semicolon, ControlMask, "\033[59;5u", 0, 0}
   #+END_SRC

**** Emacs

In emacs we only need to add the corresponding binding into the
=input-decode-map=:

#+BEGIN_SRC emacs-lisp :tangle no
(define-key input-decode-map "\e[59;5u" (kbd "C-;"))
#+END_SRC

**** Notes about upper/lower keys binding

From Emacs _Key Sequence Input_:

#+BEGIN_QUOTE
If an input character is upper-case (or has the shift modifier) and has no
key binding, but its lower-case equivalent has one, then read-key-sequence'
converts the character to lower case. Note that lookup-key' does not perform
case conversion in this way.
#+END_QUOTE
**** Notes about [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Key-Sequences.html#Key-Sequences][Key Sequences]] in Emacs
- The Emacs Lisp representation for a key sequence is a string or vector.
- The =kbd= macro returns a representation of a key sequence using some sort of
  translation.
- It is also possible to bind keys using a vector like =[C-S-M]= which will
  create a =<C-M>= binding, a different from =C-S-M=.
*** Configuration
**** Default keys

#+BEGIN_SRC emacs-lisp
(setq my-keys-debug nil
      my-keys '((?\; "XK_semicolon"    ("C" "C-M"))
                         (?:  "XK_colon"        ("C-S" "C-M-S"))
                         (?'  "XK_apostrophe"   ("C" "C-M"))
                         (?\" "XK_quotedbl"     ("C-S" "C-M-S"))
                         (?.  "XK_period"       ("C" "C-M"))
                         (?,  "XK_comma"        ("C" "C-M"))
                         (?=  "XK_equal"        ("C" "C-M"))
                         (?<  "XK_less"         ("C-S" "C-M-S"))
                         (?>  "XK_greater"      ("C-S" "C-M-S"))
                         (??  "XK_question"     ("C-S" "C-M-S"))
                         (?/  "XK_slash"        ("C" "C-M"))
                         (?\\ "XK_backslash"    ("C" "C-M"))
                         (?|  "XK_bar"          ("C-S" "C-M-S"))
                         (?~  "XK_asciitilde"   ("C-S" "C-M-S"))
                         (?`  "XK_grave"        ("C" "C-S"))
                         (?{  "XK_braceleft"    ("C-S" "C-M-S"))
                         (?}  "XK_braceright"   ("C-S" "C-M-S"))
                         (?\] "XK_bracketright" ("C" "C-M"))
                         (?\( "XK_parenleft"    ("C-S" "C-M-S"))
                         (?\) "XK_parenright"   ("C-S" "C-M-S"))
                         (?C  "XK_C"            ("C-S" "C-M-S"))
                         (?X  "XK_X"            ("C-S" "C-M-S"))
                         (?V  "XK_V"            ("C-S" "C-M-S"))
                         (?I  "XK_I"            ("C-S" "C-M-S"))
                         (?M  "XK_M"            ("C-S" "C-M-S"))
                         (?J  "XK_J"            ("C-S" "C-M-S"))
                         (?K  "XK_K"            ("C-S" "C-M-S"))
                         (?m  "XK_m"            ("C" "C-M")               (([C-m]) ([C-M-m])))
                         (?i  "XK_i"            ("C" "C-M")               (([C-i]) ([C-M-i])))
                         (?O  "XK_O"            ("C-S" "C-M-S"))
                         (? "XK_BackSpace"    ("C" "C-M" "M-S" "C-S" "C-M-S") (([C-]) ([C-M-]) ([M-S-]) ([C-S-]) ([C-M-S-])))
                         ))
#+END_SRC

- The =C-m=, =C-M-m, =C-i= and =C-M-i= can be bind using symbol =[C-m]=, etc.
  They are not =C-m=, but =<C-m>= from Emacs perspective.
- It would be possible to map as well =C-j= but that is handy for inserting the
  new line literal (using =C-q=) for example for replace.

**** =C-<number>= and =C-M-<number>= keys

#+BEGIN_SRC emacs-lisp
(let ((nums '(1 2 3 4 5 6 7 8 9)))
  (mapc (lambda (x)
          ;; DEC 48 is '0' in ASCII table
          (let* ((code (+ 48 x))
                 (e (list code (format "XK_%d" x) (list "C" "C-M"))))
            (setq my-keys (append my-keys (list e)))))
        nums))
#+END_SRC

**** Auxiliary functions

#+BEGIN_SRC emacs-lisp
(defun flatten (list-of-lists)
  (apply #'append list-of-lists))

(defun join (sep lst)
   (mapconcat 'identity lst sep))

 (defun zip (xs ys)
   (if (and (null xs) (null ys))
       ()
     (cons (cond
            ((null xs) (cons '(nil) (car ys)))
            ((null ys) (cons (car xs) '(nil)))
            (t (cons (car xs) (car ys))))
           (zip (cdr xs) (cdr ys)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defconst my--my-keys-prefix "\033["
  "Escape code sequence prefix")

(defconst my--my-keys-suffix "u"
  "Escape code sequence suffix")

(defconst my--my-keys-modifiers
  '(("M"     . ("Mod1Mask"                           3))
    ("M-S"   . ("Mod1Mask | ShiftMask"               4))
    ("C"     . ("ControlMask"                        5))
    ("C-S"   . ("ControlMask | ShiftMask"            6))
    ("C-M"   . ("ControlMask | Mod1Mask"             7))
    ("C-M-S" . ("ControlMask | Mod1Mask | ShiftMask" 8)))
  "The key modifiers as triplets of st emacs name, st name and code")

(defun my--encode-key-mod (key-code mod-code)
  (format "%s%d;%d%s" my--my-keys-prefix key-code mod-code my--my-keys-suffix))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun my--iterate-keys (fun)
  (mapcan
   (lambda (key)
     (let ((key-code (car key))
           (key-sym (cadr key))
           (mods (caddr key))
           (keys-emacs (cadddr key)))
       (mapcar
        (lambda (x)
          (let* ((mod (car x))
                 (key-emacs (cadr x))
                 (mod-info (cdr (assoc mod my--my-keys-modifiers))))
            (funcall fun key-code key-sym mod mod-info key-emacs)))
        (zip mods keys-emacs))))
   my-keys))
#+END_SRC

**** Enabling my-keys in st

#+BEGIN_SRC emacs-lisp
(defun my--escape-string (s)
  (mapconcat
   (lambda (x)
     (if (and (>= x 32) (<= x 255))
         (format "%c" x)
       (format "\\x%02X" x)))
   (append s nil)
   ""))

(defun my--st-encode-keys ()
  (delete-dups
   (my--iterate-keys
    (lambda (key-code key-sym mod mod-info key-emacs)
      (let ((mod-sym (car mod-info))
            (mod-code (cadr mod-info)))
        (format "{%s, %s, \"%s\", 0, 0}"
                key-sym
                mod-sym
                (my--escape-string (my--encode-key-mod key-code mod-code))))))))

(defun my--st-encode-mapped-keys ()
  (delete-dups
   (my--iterate-keys
    (lambda (key-code key-sym mod mod-info key-emacs)
      (format "%s" key-sym)))))

(defun my-st-sync-mapped-keys ()
  (interactive)
  (with-temp-buffer
    (insert (concat (join ",\n" (my--st-encode-keys)) ",\n"))
    (write-region (point-min) (point-max) (expand-file-name "my-keys.h" my-st-dir)))

  (with-temp-buffer
    (insert (concat (join ",\n" (my--st-encode-mapped-keys)) ",\n"))
    (write-region (point-min) (point-max) (expand-file-name "my-mapped-keys.h" my-st-dir))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
(my-st-sync-mapped-keys)
#+END_SRC

**** Enabling my-keys in Emacs

Make Emacs aware of these new keys using the [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Translation-Keymaps.html][input-decode-map]].

#+BEGIN_SRC emacs-lisp
(defun my-emacs-encode-keys ()
  (my--iterate-keys
   (lambda (key-code key-sym mod mod-info key-emacs)
     (let* ((mod-code (cadr mod-info))
            (input (my--encode-key-mod key-code mod-code))
            (key (if (null key-emacs)
                     (kbd (format "%s-%c" mod key-code))
                   key-emacs)))
       (when my-keys-debug
         (message "binding: %s to %s (%s-%c)" input key mod key-code))

       ;(define-key input-decode-map input key)
       (define-key xterm-function-map input key)))))

(when my-keys
  (message "Enabling my-keys")
  (eval-after-load "xterm" '(my-emacs-encode-keys)))
;;(unless (display-graphic-p)
;;  (my-emacs-encode-keys))
#+END_SRC

**** TODO should this go the the xterm-function-map instead?
- try it in GUI to see what works better
- try it in Xterm
- try term keys
** TODO input map in GUI
- sync it with terminal
** Customize file =custom.el=                                          :wip:

Set up the customize file to its own separate file, instead of saving
customize settings in [[file:init.el][init.el]].

*** TODO what to do with the custom file? Keep it, keep it, but not version it or send to /tmp

#+BEGIN_SRC emacs-lisp
(setq custom-file (emacs-path "custom.el"))
(unless (file-exists-p custom-file)
    (write-region "" nil custom-file))
;(load custom-file)
#+END_SRC

** Install hydra

#+BEGIN_SRC emacs-lisp
(use-package hydra)
#+END_SRC

** Enable some useful functions

These functions are useful so activate them.

#+BEGIN_SRC emacs-lisp
(put 'downcase-region 'disabled nil)
(put 'upcase-region 'disabled nil)
(put 'narrow-to-region 'disabled nil)
(put 'dired-find-alternate-file 'disabled nil)
(put 'erase-buffer 'disabled nil)
(put 'scroll-left 'disabled nil)
#+END_SRC

** File backup                                                         :wip:
*** TODO better way to handle backups
*** Backup files

Create the directory if it does not exist yet.

#+BEGIN_SRC emacs-lisp
(unless (file-exists-p my-backup-dir)
  (make-directory my-backup-dir t))
#+END_SRC

I don't want all files to be automatically backed up. Here is a sample filer.

#+BEGIN_SRC emacs-lisp
(defvar my-backup-ignore-regexps '("^/dev/shm/pass.*" "COMMIT_EDITMSG")
  "List of filename regexps not to backup")

(defun my-backup-enable-p (name)
  "Check whether the filename name should be backuped or not"
  (when (normal-backup-enable-predicate name)
    (let ((backup t))
      (mapc (lambda (re)
              (setq backup (and backup (not (string-match re name)))))
            my-backup-ignore-regexps)
      backup)))
#+END_SRC

Backup settings

#+BEGIN_SRC emacs-lisp
(setq
      backup-enable-predicate           'my-backup-enable-p
      backup-directory-alist            `(("." . ,my-backup-dir))
      backup-by-copying                  t
      delete-old-versions                t
      kept-new-versions                  6
      kept-old-versions                  2
      make-backup-files                  t
      version-control                    t
)
#+END_SRC

*** Auto-save files

#+BEGIN_SRC emacs-lisp
(unless (file-exists-p my-auto-save-dir)
  (make-directory my-auto-save-dir t))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq
      auto-save-default                  t
      auto-save-list-file-name           my-auto-save-dir
      auto-save-file-name-transforms     `(
                                           ;; remote files
                                           ("\\`/[^/]*:\\([^/]*/\\)*\\([^/]*\\)\\'" "/tmp/\\2" t)
                                           ;; local files
                                           ("\\(.*\\)" ,(concat my-auto-save-dir "/a") t))
)
#+END_SRC

*** Lock files

#+BEGIN_SRC emacs-lisp
(setq create-lockfiles nil)
#+END_SRC

*** History

#+BEGIN_SRC emacs-lisp
(setq history-length 1000)
#+END_SRC

*** TODO backup walker
** Auto save file buffers

Automatically save buffers associated with files on buffer switch
and on windows switch.

#+BEGIN_SRC emacs-lisp
(use-package super-save
  :defer 2
  :unless noninteractive
  :diminish (super-save-mode . "AS")
  :custom
  (super-save-auto-save-when-idle t)
  (super-save-idle-duration 30)
  :config
  ;; add integration with ace-window
  (add-to-list 'super-save-triggers 'ace-window)
  (add-to-list 'super-save-triggers 'winum-select-window-by-number)
  (add-to-list 'super-save-hook-triggers 'find-file-hook)
  (super-save-mode 1))
#+END_SRC

*** TODO trigger on buffer change
- just select-window is not enough as we need to find what is the new window.

** Use UTF-8

#+BEGIN_SRC emacs-lisp
(prefer-coding-system 'utf-8)

;; Accept 'UTF-8' (uppercase) as a valid encoding in the coding header
(define-coding-system-alias 'UTF-8 'utf-8)
#+END_SRC
** Define my-minor-mode that will define all my global key bindings

#+BEGIN_SRC emacs-lisp
(defvar my-key-map (make-sparse-keymap)
  "my-minor-mode keymap.")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(define-minor-mode my-minor-mode
  :init-value t
  :lighter "MY"
  :keymap my-key-map)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun my-keys-have-priority (_file)
  "Try to ensure that my keybindings retain priority over other minor modes.
Called via the `after-load-functions' special hook."

  (unless (eq (caar minor-mode-map-alist) 'my-minor-mode)
    (let ((my (assq 'my-minor-mode minor-mode-map-alist)))
      (assq-delete-all 'my-minor-mode minor-mode-map-alist)
      (add-to-list 'minor-mode-map-alist my))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(my-minor-mode 1)

(add-hook 'after-load-functions 'my-keys-have-priority)
#+END_SRC

** Sensible defaults

Taken mostly from the [[https://github.com/hrs/sensible-defaults.el/blob/master/sensible-defaults.el][sensible-defaults.el]] and [[http://www.emacs-bootstrap.com/][emacs-bootstrap]].

*** Eval expression

#+BEGIN_SRC emacs-lisp
(bind-key "M-:" 'eval-expression)
#+END_SRC

*** Yes/No confirmation

Answering just 'y' or 'n' will do

#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

*** Defaults

#+BEGIN_SRC emacs-lisp
(setq
      ;; apropos searches more extensively
      apropos-do-all                      t
      ;; indent or if indeneted, complete
      tab-always-indent                   'complete
      confirm-nonexistent-file-or-buffer  t

      ;; save existing clipboard into kill ring before replacing it
      save-interprogram-paste-before-kill t
      ;; when middle-clicking the mouse to yank from the clipboard, insert the text where point is, not where the mouse cursor is
      mouse-yank-at-point                 t
      require-final-newline               t
      ;; this the most useful setting
      visible-bell                        nil
      ;; http://ergoemacs.org/emacs/emacs_stop_cursor_enter_prompt.html
      minibuffer-prompt-properties        '(read-only t point-entered minibuffer-avoid-prompt face minibuffer-prompt)
      ;; Disable non selected window highlight
      cursor-in-non-selected-windows      nil
      highlight-nonselected-windows       nil
      ;; PATH
      exec-path                           (append exec-path '("/usr/local/bin/"))
      ;; single space to indicate end of a sentance
      sentence-end-double-space           nil
      select-enable-clipboard             t
      ;; -i gets alias definitions from shell
      shell-command-switch                "-ic"
      echo-keystrokes                     0.1
      use-dialog-box                      nil
      kill-ring-max                       300
      initial-major-mode                  'text-mode
      cursor-in-non-selected-windows      t
      ;; when opening a file, follow symlinks
      vc-follow-symlinks                  t
      require-final-line                  t
      ;; Activate character folding in searches i.e. searching for 'a' matches 'ä' as well
      search-default-mode                 'char-fold-to-regexp
)

(setq-default
      ;; always just use left-to-right text this makes Emacs a bit faster for very long lines
      bidi-display-reordering             nil
      tab-width                           2
      indent-tabs-mode                    nil
      ;; maximum line width
      fill-column                         79
      ;; don't fold lines
      truncate-lines                      t
      frame-title-format                  '("%b")
      indicate-empty-lines                t
      cursor-type                         'bar
      display-line-numbers-grow-only      t
      display-line-numbers-width-start    t
      show-paren-delay                    0.0
      imenu-auto-rescan                   t
)

(blink-cursor-mode -1)
(delete-selection-mode t)
(show-paren-mode t)
(column-number-mode t)
(global-visual-line-mode t)
(global-hl-line-mode t)
(transient-mark-mode t)
(toggle-truncate-lines t)
(whitespace-mode -1)
(size-indication-mode t)

(diminish 'visual-line-mode " ↩")
#+END_SRC
*** Enable line numbers

#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook #'display-line-numbers-mode)
(add-hook 'text-mode-hook #'display-line-numbers-mode)
#+END_SRC

*** Nicer scrolling

#+BEGIN_SRC emacs-lisp
(setq scroll-margin 0
      scroll-step 1
      scroll-error-top-bottom t
      scroll-conservatively 100000
      scroll-preserve-screen-position 1
      ;; disable auto vscroll (makes scrolling down a bit faster?)
      auto-window-vscroll nil)
#+END_SRC

**** TODO make sure this work with the pdf-tools

*** Turn on syntax highlighting whenever possible

#+begin_src emacs-lisp
(global-font-lock-mode t)
#+end_src

*** When saving a file that starts with =#!=, make it executable

#+BEGIN_SRC emacs-lisp
(add-hook 'after-save-hook
          'executable-make-buffer-file-executable-if-script-p)
#+END_SRC

*** Popup window management

#+BEGIN_SRC emacs-lisp
(use-package popwin
  :demand t
  :config
  (popwin-mode 1))
#+END_SRC

The package seems not to be maintained, an alternative might be [[https://github.com/wasamasa/shackle][shackle]].
*** TODO replace popwin with better one
*** Save placesss

This remembers your location in a file when saving files.

#+BEGIN_SRC emacs-lisp
(use-package saveplace
  :demand t
  :unless noninteractive
  :custom
  (save-place-file (expand-file-name "save-places" my-private-conf-dir)))

(save-place-mode 1)
#+END_SRC
*** Meaningful names for buffers with the same name

#+BEGIN_SRC emacs-lisp
(setq uniquify-buffer-name-style 'forward
      uniquify-separator "/"
      ;; rename after killing uniquified
      uniquify-after-kill-buffer-p t
      ;; don't muck with special buffers
      uniquify-ignore-buffers-re "^\\*")
#+END_SRC

*** Track history

#+BEGIN_SRC emacs-lisp
;; savehist keeps track of some history
(use-package savehist
  :demand t
  :unless noninteractive
  :custom
  ;; search entries
  (savehist-additional-variables '(search-ring regexp-search-ring compile-command kill-ring))
  ;; save every minute
  (savehist-autosave-interval 60)
  ;; keep the home clean
  (savehist-file (expand-file-name "save-history" my-private-conf-dir))
  :config
  (savehist-mode 1))
#+END_SRC

*** Recent files tracking

#+BEGIN_SRC emacs-lisp
(use-package recentf
  :demand t
  :custom
  (recentf-save-file (expand-file-name "recentf" my-private-conf-dir))
  (recentf-max-saved-items 500)
  (recentf-max-menu-items 15)
  ;; disable recentf-cleanup on Emacs start, because it can cause
  ;; problems with remote files
  (recentf-auto-cleanup 'never)
  :config
  (recentf-mode +1))
#+END_SRC
*** <end> is the same as =C-e=

#+BEGIN_SRC emacs-lisp
(bind-key "<end>" #'move-end-of-line my-key-map)
#+END_SRC

** Install crux

This package defines a bunch of useful functions that I would otherwise had to
define.

#+BEGIN_SRC emacs-lisp
(use-package crux
  :commands
  crux-smart-open-line-above
  crux-smart-open-line
  crux-open-with
  crux-top-join-line
  crux-rename-file-and-buffer
  crux-with-region-or-line
  crux-kill-line-backwards
  crux-kill-whole-line)
#+END_SRC

These command will be used in the [[Editing]] and [[Navigation]].

** Minibuffer

#+BEGIN_SRC emacs-lisp
(use-package minibuffer
  :ensure nil
  :config
  (defun my-minibuffer-setup-hook ()
    (setq gc-cons-threshold most-positive-fixnum))

  (defun my-minibuffer-exit-hook ()
    (setq gc-cons-threshold 800000))

  (add-hook 'minibuffer-setup-hook #'my-minibuffer-setup-hook)
  (add-hook 'minibuffer-exit-hook #'my-minibuffer-exit-hook))
#+END_SRC
** Revert buffers

Revert buffers when files on disk change

#+BEGIN_SRC emacs-lisp
(use-package autorevert
  :defer 3
  :custom
  ;; auto refresh dired, but be quiet about it
  (global-auto-revert-non-file-buffers t)
  ;; revert pdf without asking
  (auto-revert-verbose nil)
  (revert-without-query '("\\.pdf"))
  :config
  (global-auto-revert-mode 1))
#+END_SRC

** TODO prettify symbol mode
(setq-default prettify-symbols-alist
                '(("#+BEGIN_SRC"     . "λ")
                  ("#+END_SRC"       . "λ"))

* Appearance
** Theme
*** base16-oceanicnext theme

#+BEGIN_SRC emacs-lisp
(use-package base16-theme
  :demand t
  :config
  (load-theme 'base16-oceanicnext t))
#+END_SRC
*** Region selection color

#+BEGIN_SRC emacs-lisp
(set-face-attribute 'region nil :foreground "black" :background "magenta")
#+END_SRC

** Font

#+BEGIN_SRC emacs-lisp
(add-to-list 'default-frame-alist
  (cond
    ((string-equal system-type "darwin")    '(font . "dejavu sans mono"))
    ((string-equal system-type "gnu/linux") '(font . "dejavu sans mono"))))
#+END_SRC

*** TODO font size hydra

** Modeline
*** TODO better modeline?

#+BEGIN_SRC emacs-lisp :tangle no
(use-package powerline
  :demand t
  :config
  (powerline-default-theme))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
(use-package doom-modeline
  :demand t
  :config
  (add-hook 'after-init-hook #'doom-modeline-init)
  :custom
  (doom-modeline-icon nil)
  (doom-modeline-minor-modes t)
  (doom-modeline-buffer-encoding t)
  (doom-modeline-buffer-file-name-style 'buffer-name)
)
#+END_SRC
** Cursor
*** TODO bar cursor
*** Color
**** Functions

- TODO: defvar for shape and color at the beginning

#+BEGIN_SRC emacs-lisp
(defconst my-cursor-types '((box-blink  . 1)
                                  (box        . 2)
                                  (hbar-blink . 3)
                                  (hbar       . 4)
                                  (bar-blink  . 5)
                                  (bar        . 6))
  "Available cursor types as tuple of name and terminal code")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun my--tmux-p ()
  "Running in tmux."
  (getenv "TMUX"))

(defun my--make-tmux-seq (seq)
  (format "\ePtmux;\e%s\e\\" seq))

(defun my--cursor-shape-seq (shape)
  "Make escape sequence for XTerm compatible terminals."
  (let* ((cursor-code (cdr (assoc shape my-cursor-types)))
         (seq (format "\e[%d q" cursor-code)))
    (if (my--tmux-p)
        (my--make-tmux-seq seq)
      seq)))

(defun my-set-cursor-shape (shape)
  (let ((seq (my--cursor-shape-seq shape)))
    (message "%s" seq)
    (send-string-to-terminal seq)))

(defun my--cursor-color-seq (color)
  "Make escape sequence for cursor color (in HEX)."
  (let ((seq (format "\e]12;%s\a" color)))
    (if (my--tmux-p)
        (my--make-tmux-seq seq)
      seq)))

(defun my-set-cursor-color (color)
  (let ((seq (my--cursor-color-seq color)))
    (message "%s" seq)
    (send-string-to-terminal seq)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(set-cursor-color "#ee30a7")
(setq-default cursor-type 'bar)
#+END_SRC
**** TODO cursor color in GUI

**** TODO sync with tmux region color 30;45 ideally

*** TODO better indication of current chunk in magit
* Editing
** Killing words

I prefer fine-grained killing :-)

#+BEGIN_SRC emacs-lisp
(defun my-kill-syntax (&optional arg)
  (interactive "p")
  (let ((opoint (point)))
    (forward-same-syntax arg)
    (kill-region opoint (point))))

(defun my-backward-kill-syntax (&optional arg)
  (interactive)
(my-kill-syntax -1))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(bind-key "<C-backspace>" #'my-backward-kill-syntax my-key-map)
(bind-key "M-DEL" #'my-backward-kill-syntax my-key-map)
(bind-key [M-S-] #'crux-kill-line-backwards my-key-map)
#+END_SRC

*** TODO There should be also GUI version.                   :check:in:gui:

** Killing lines

#+BEGIN_SRC emacs-lisp
(bind-key "C-S-K" #'crux-kill-whole-line my-key-map)
(bind-key [remap kill-whole-line] #'crux-kill-whole-line my-key-map)
#+END_SRC

*** TODO There should be also GUI version.                   :check:in:gui:

** Mark words and SEXPs

Similarly to killing by syntax, mark by syntax as well.

#+BEGIN_SRC emacs-lisp
(defun my-mark-syntax (&optional arg)
  "Based on the `mark-word` but using `forward-same-synax`
instead of `forward-word`."
  (interactive "P")
  (cond ((or (and (eq last-command this-command) (mark t))
             (region-active-p))
         (setq arg (if arg (prefix-numeric-value arg)
                     (if (< (mark) (point)) -1 1)))
         (set-mark
          (save-excursion
            (goto-char (mark))
            (forward-same-syntax arg)
            (point))))
        (t
         (push-mark
          (save-excursion
            (forward-same-syntax (prefix-numeric-value arg))
            (point))
          nil t))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(bind-key "M-c" #'my-mark-syntax my-key-map)
(bind-key "M-C" #'mark-sexp my-key-map)
#+END_SRC

** Deleting spaces

| Key     | Description                                                | Function                 |
|---------+------------------------------------------------------------+--------------------------|
| =M-\=   | Delete all spaces and tabs around point                    | =delete-horizonal-space= |
| =M-SPC= | Delete all spaces and tabs around point, leaving one space | =just-one-space=         |

** Copy and paste
*** Functions

These functions allow to C&P to the system clipboard using either terminal
escape code or xsel command if running in GUI.

#+BEGIN_SRC emacs-lisp
(defun my-copy-to-xclipboard ()
  (interactive)
  (if (use-region-p)
      (if (not (display-graphic-p))
          (letrec ((s (buffer-substring-no-properties (region-beginning) (region-end)))
                   (s-length (+ (* (length s) 3) 2)))
            (if (<= s-length 16384) ; magic number set to the same as ESC_BUF_SIZ of suckless termial (st.c)
                (progn
                  (send-string-to-terminal (concat "\e]52;c;"
                                                   (base64-encode-string (encode-coding-string s 'utf-8) t)
                                                   "\07"))
                  (message "Yanked region to terminal clipboard")
                  (deactivate-mark))
              (message "Selection too long (%d) to send to terminal." s-length)))
        (if (= 0 (shell-command-on-region (region-beginning) (region-end) "xsel -i -b"))
            (message "Yanked region to X-clipboard")
          (error "Is program `xsel' installed?")))
    (message "Nothing to yank to terminal clipboard")))

(defun my-cut-to-xclipboard ()
  (interactive)
  (my-copy-to-xclipboard)
  (kill-region (region-beginning) (region-end)))

(defun my-paste-from-xclipboard ()
  "Uses shell command `xsel -o' to paste from x-clipboard. With
one prefix arg, pastes from X-PRIMARY, and with two prefix args,
pastes from X-SECONDARY."
  (interactive)
  (if (display-graphic-p)
      (clipboard-yank)
    (letrec
        ((opt (prefix-numeric-value current-prefix-arg))
         (opt (cond
               ((=  1 opt) "b")
               ((=  4 opt) "p")
               ((= 16 opt) "s"))))
(insert (shell-command-to-string (concat "xsel -o -" opt))))))
#+END_SRC

*** Bind keys

Bind =C-S-X= to cut and =C-X-C= to copy.

#+BEGIN_SRC emacs-lisp
(bind-key "C-S-X" 'my-cut-to-xclipboard my-key-map)
(bind-key "C-S-C" 'my-copy-to-xclipboard my-key-map)
#+END_SRC

The paste shortcut (=C-S-V=) we only want in GUI. When running in terminal it
is better to use the terminal paste since it will be a [[https://cirw.in/blog/bracketed-paste][bracketed paste]].

#+BEGIN_SRC emacs-lisp
(when (display-graphic-p)
  (bind-key "C-S-V" 'my-paste-from-xclipboard my-key-map))
#+END_SRC

** Fill/unfill paragraph

#+BEGIN_SRC emacs-lisp
(use-package unfill
  :commands (unfill-region unfill-paragraph unfill-toggle)
  :bind
  ([remap fill-paragraph] . unfill-toggle))
#+END_SRC

** iedit

Start iedit on the current line only.

| Key   | Action                                        |
|-------+-----------------------------------------------|
| =M-n= | Select next occurrence                        |
| =M-p= | Select previous occurrence                    |
| =M-{= | Extend the search region by the next line     |
| =M-}= | Extend the search region by the previous line |
| =M-H= | Narrow the search region to current defun     |
| =M-I= | Narrow the search region to current line      |

#+BEGIN_SRC emacs-lisp
(use-package iedit
  :demand t
  :config
  (set-face-attribute 'iedit-occurrence nil :foreground "black" :background "brightblack"))
#+END_SRC

*** TODO start with narrow to current line

Adding a hook like:

#+BEGIN_SRC emacs-lisp :tangle no
  :preface
  (defun my-iedit-mode-narrow-to-current-line ()
    (iedit-restrict-current-line))
  :hook
  (iedit-mode . my-iedit-mode-narrow-to-current-line))
#+END_SRC

does not work.

** Move lines up / down
*** TODO fix this in org-mode which takes over this binding

What I want is:
- M-up/down move lines / region
- M-S-up/down duplicate lines / region

In org mode:
- M-up at heading / table moves subtree / row
- M-S-up/down duplicate lines / region

#+BEGIN_SRC emacs-lisp
(use-package move-dup
  :bind
  ("M-<up>" . md-move-lines-up)
  ("M-<down>" . md-move-lines-down)
  ("M-S-<up>" . md-duplicate-up)
  ("M-S-<down>" . md-duplicate-down))
#+END_SRC

** Join lines

The =join-line= command (aliased to =delete-indentation=) works from the last
line to be joined upwards. Most of the time I prefer the other way around.

| Key   | Description                                       |
|-------+---------------------------------------------------|
| =M-j= | Join the current line with the line *beneath* it. |
| =M-J= | Join the current line with the line *over* it.    |

#+BEGIN_SRC emacs-lisp
(bind-key "M-j" #'crux-top-join-line my-key-map)
(bind-key "M-J" #'join-line my-key-map)
#+END_SRC

** Open line above and bellow

#+BEGIN_SRC emacs-lisp
(bind-key "C-S-O" #'crux-smart-open-line-above my-key-map)
(bind-key "C-o" #'crux-smart-open-line my-key-map)
#+END_SRC

** Comment / un-comment lines

First, we extend the functionality of the =comment-or-uncomment-region= to work
on a single line in the case no region is active:

#+BEGIN_SRC emacs-lisp
(crux-with-region-or-line comment-or-uncomment-region)
#+END_SRC

Next, we bind it:

#+BEGIN_SRC emacs-lisp
(bind-key "C-/" #'comment-or-uncomment-region my-key-map)
#+END_SRC

** Copy and cut whole lines

If no region is active, make the =M-w= and =C-w= copy and cut whole line
respectivelly.

#+BEGIN_SRC emacs-lisp
(crux-with-region-or-line kill-region)
(crux-with-region-or-point-to-eol kill-ring-save)
#+END_SRC

** Expand region (=C-==)

Define a function that simply selects the current line.

#+BEGIN_SRC emacs-lisp
(defun my-select-line ()
  "Select current line. If region is active, extend selection downward by line."
  (interactive)
  (if (region-active-p)
      (progn
        (forward-line 1)
        (end-of-line))
    (progn
      (end-of-line)
      (set-mark (line-beginning-position)))))
#+END_SRC

Define the =M-r= prefix and use it for expand region, including the line
selection defined above.

The reason I have to add an advice is that I use a custom mapping for =C-==
(=[61;5u=) so the original =er/prepare-for-more-expansions-internal= will
return =u= as the keybinding for expand more region instead of ===.

#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :preface
  (defun my--er-prepare-for-more-expansions-internal (orig &rest r)
    (funcall orig "="))
  :config
  (advice-add 'er/prepare-for-more-expansions-internal :around #'my--er-prepare-for-more-expansions-internal)
  :bind
  ("C-=" . er/expand-region)
  (:prefix "C-c C-="
   :prefix-map my-expand-region-map
   ("="  . er/expand-region)
   ("("  . er/mark-inside-pairs)
   (")"  . er/mark-outside-pairs)
   ("'"  . er/mark-inside-quotes)
   ("\"" . er/mark-outside-quotes)
   ("o" . er/mark-org-parent)
   ("u" . er/mark-url)
   ("b" . er/mark-org-code-block)
   ("." . er/mark-method-call)
   (">" . er/mark-next-accessor)
   ("w" . er/mark-word)
   ("d" . er/mark-defun)
   ("e" . er/mark-email)
   ("," . er/mark-symbol)
   ("<" . er/mark-symbol-with-prefix)
   (";" . er/mark-comment)
   ("s" . er/mark-sentence)
   ("S" . er/mark-text-sentence)
   ("p" . er/mark-paragraph)
   ("P" . er/mark-text-paragraph)
   ("l" . my-select-line)))
#+END_SRC

** Snippets                                                          :hydra:

#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :defer 1
  :diminish (yas-minor-mode . "YAS")
  :custom
  (yas-snippet-dirs `(,my-snippets-dir))
  :commands yas-minor-mode
  :bind (:prefix "C-c s"
         :prefix-map my-yasnippet-map
         :prefix-docstring "Yasnippet key"
         ("i" . yas-insert-snippet)
         ("n" . yas-new-snippet)
         ("f" . yas-visit-snippet-file)
         ("r" . yas-reload-all)
         ("x" . yas-expand)
         ("t" . yas-tryout-snippet)
         ("l" . yas-describe-tables))
  :config
  (yas-global-mode 1)
  (yas-reload-all))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package ivy-yasnippet
  :bind (:map my-yasnippet-map
              ("s" . ivy-yasnippet)))
#+END_SRC

** Auto completion
*** Company mode

#+BEGIN_SRC emacs-lisp
(use-package company
  :defer 2
  :diminish (company-mode . "AC")
  :commands (company-mode company-indent-or-complete-common)
  :custom
  (company-idle-delay 0.1)
  (company-tooltip-limit 10)
  (company-minimum-prefix-length 2)
  (company-tooltip-align-annotations t)
  (company-begin-commands '(self-insert-command))
  (company-dabbrev-ignore-case t)
  (company-dabbrev-code-ignore-case t)
  (company-dabbrev-downcase t)
  :hook
  (after-init . global-company-mode)
  :bind (:map company-active-map
              ([tab] . nil)
              ("TAB" . nil)))
#+END_SRC

**** [[https://github.com/expez/company-quickhelp][company-quick-help]]

#+BEGIN_SRC emacs-lisp
(use-package company-quickhelp
  :after company
  :bind (:map company-active-map
              ("C-c ?" . company-quickhelp-manual-begin)))
#+END_SRC
*** Abbrevs

#+BEGIN_SRC emacs-lisp
(use-package abbrev
  :ensure nil
  :custom
  (abbrev-file-name (expand-file-name "abbrev-defs" my-private-conf-dir))
  (save-abbrevs 'silently))
#+END_SRC

*** Hippie expand

#+BEGIN_SRC emacs-lisp
(use-package hippie-exp
  :bind
  ([remap dabbrev-expand] . hippie-expand)
  :custom
  (hippie-expand-try-functions-list '(try-expand-dabbrev
                                      try-expand-dabbrev-all-buffers
                                      try-expand-dabbrev-from-kill
                                      try-complete-file-name-partially
                                      try-complete-file-name
                                      try-expand-all-abbrevs
                                      try-expand-list
                                      try-expand-line
                                      try-complete-lisp-symbol-partially
                                      try-complete-lisp-symbol)))
#+END_SRC

** TODO delete syntax
** wgrep

#+BEGIN_SRC emacs-lisp
(use-package wgrep
  :demand t
  :custom
  (wgrep-auto-save-buffer t)
  (wgrep-enable-key "e"))
#+END_SRC

** Spell checking
*** ispell

#+BEGIN_SRC emacs-lisp
(use-package ispell
  :defer 3
  :custom
  (ispell-personal-dictionary (expand-file-name "my-ispell-dictionary" my-private-conf-dir))
  (ispell-dictionary "en_US")
  (ispell-program-name (executable-find "aspell"))
  (ispell-really-hunspell t)
  (ispell-silently-savep t))
#+END_SRC

*** flyspell

#+BEGIN_SRC emacs-lisp
(use-package flyspell
  :after ispell
  :hook
  (text-mode . flyspell-mode)
  (prog-mode . flyspell-prog-mode)
  :bind (:map flyspell-mode-map
              ("C-;" . nil)
              ("C-," . nil))
  :custom
  (flyspell-abbrev-p t)
  (flyspell-issue-welcome-flag nil))
#+END_SRC

*** flyspell / ivy integration

#+BEGIN_SRC emacs-lisp
(use-package flyspell-correct-ivy
  :after (flyspell ivy)
  :init
  (setq flyspell-correct-interface #'flyspell-correct-ivy)
  :bind
  ("M-'" . flyspell-correct-wrapper))
#+END_SRC

*** TODO functions to change dictionaries

Something like:

#+BEGIN_SRC emacs-lisp :tangle no
(lambda ()
  (interactive)
  (ispell-change-dictionary "en_GB")
  (flyspell-buffer))
#+END_SRC

and use ivy to propose the available dictionaries.

** TODO surround
- https://github.com/ganmacs/emacs-surround
** Rainbow delimiters

#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :hook
  (prog-mode . rainbow-delimiters-mode))
#+END_SRC
** TODO highlight-parenthesis-mode?
** TODO smartparens

from: https://ensime.github.io/editors/emacs/hacks/#general
#+BEGIN_SRC emacs-lisp :tangle no
(use-package smartparens
  :diminish smartparens-mode
  :commands
  smartparens-strict-mode
  smartparens-mode
  sp-restrict-to-pairs-interactive
  sp-local-pair
  :init
  (setq sp-interactive-dwim t)
  :config
  (require 'smartparens-config)
  (sp-use-smartparens-bindings)

  (sp-pair "(" ")" :wrap "C-(") ;; how do people live without this?
  (sp-pair "[" "]" :wrap "s-[") ;; C-[ sends ESC
  (sp-pair "{" "}" :wrap "C-{")

  ;; WORKAROUND https://github.com/Fuco1/smartparens/issues/543
  (bind-key "C-<left>" nil smartparens-mode-map)
  (bind-key "C-<right>" nil smartparens-mode-map)

  (bind-key "s-<delete>" 'sp-kill-sexp smartparens-mode-map)
  (bind-key "s-<backspace>" 'sp-backward-kill-sexp smartparens-mode-map))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
(use-package smartparens
  :defer 1
  :hook ((
          emacs-lisp-mode lisp-mode hy-mode go-mode cc-mode
          python-mode typescript-mode javascript-mode java-mode
          ) . smartparens-strict-mode)
  ;; :hook (prog-mode . smartparens-strict-mode)
  :bind (:map smartparens-mode-map
         ;; This is the paredit mode map minus a few key bindings
         ;; that I use in other modes (e.g. M-?)
         ("C-M-f" . sp-forward-sexp) ;; navigation
         ("C-M-b" . sp-backward-sexp)
         ("C-M-u" . sp-backward-up-sexp)
         ("C-M-d" . sp-down-sexp)
         ("C-M-p" . sp-backward-down-sexp)
         ("C-M-n" . sp-up-sexp)
         ("M-s" . sp-splice-sexp) ;; depth-changing commands
         ("M-r" . sp-splice-sexp-killing-around)
         ("M-(" . sp-wrap-round)
         ("C-)" . sp-forward-slurp-sexp) ;; barf/slurp
         ("C-<right>" . sp-forward-slurp-sexp)
         ("C-}" . sp-forward-barf-sexp)
         ("C-<left>" . sp-forward-barf-sexp)
         ("C-(" . sp-backward-slurp-sexp)
         ("C-M-<left>" . sp-backward-slurp-sexp)
         ("C-{" . sp-backward-barf-sexp)
         ("C-M-<right>" . sp-backward-barf-sexp)
         ("M-S" . sp-split-sexp) ;; misc
         ("M-j" . sp-join-sexp))
  :config
  (require 'smartparens-config)
  (setq sp-base-key-bindings 'paredit)
  (setq sp-autoskip-closing-pair 'always)

  ;; Always highlight matching parens
  (show-smartparens-global-mode +1)
  (setq blink-matching-paren nil)  ;; Don't blink matching parens

  ;; Create keybindings to wrap symbol/region in pairs
  (defun prelude-wrap-with (s)
    "Create a wrapper function for smartparens using S."
    `(lambda (&optional arg)
       (interactive "P")
       (sp-wrap-with-pair ,s)))
  (define-key prog-mode-map (kbd "M-(") (prelude-wrap-with "("))
  (define-key prog-mode-map (kbd "M-[") (prelude-wrap-with "["))
  (define-key prog-mode-map (kbd "M-{") (prelude-wrap-with "{"))
  (define-key prog-mode-map (kbd "M-\"") (prelude-wrap-with "\""))
  (define-key prog-mode-map (kbd "M-'") (prelude-wrap-with "'"))
  (define-key prog-mode-map (kbd "M-`") (prelude-wrap-with "`"))

  ;; smart curly braces
  (sp-pair "{" nil :post-handlers
           '(((lambda (&rest _ignored)
                (crux-smart-open-line-above)) "RET")))
  (sp-pair "[" nil :post-handlers
           '(((lambda (&rest _ignored)
                (crux-smart-open-line-above)) "RET")))
  (sp-pair "(" nil :post-handlers
           '(((lambda (&rest _ignored)
                (crux-smart-open-line-above)) "RET")))

  ;; use smartparens-mode everywhere
  (smartparens-global-mode))
#+END_SRC

** Indentation

#+BEGIN_SRC emacs-lisp
(defun my-reformat-buffer ()
  "Indent the entire buffer, remove trailing white space and tabs"
  (interactive)
  (save-excursion
    (delete-trailing-whitespace)
    (indent-region (point-min) (point-max) nil)
    (untabify (point-min) (point-max))))
#+END_SRC

** TODO macros
- hydra with dribble / loosage
** Automatically remove trailing whitespace

But, only if I put them there!

#+BEGIN_SRC emacs-lisp
(use-package ws-butler
  :hook ((text-mode prog-mode) . ws-butler-mode)
  :config (setq ws-butler-keep-whitespace-before-point nil))
#+END_SRC

** Regexp builder

#+BEGIN_SRC emacs-lisp
(use-package re-builder
  :defer t
  :config (setq reb-re-syntax 'string))
#+END_SRC
** Zap to char

#+BEGIN_SRC emacs-lisp
(bind-key "M-Z" #'zap-to-char)
(bind-key "M-z" #'zap-up-to-char)
#+END_SRC

* Movement and navigation
** Generic completion with Ivy

#+BEGIN_SRC emacs-lisp
(use-package ivy
  :demand t
  :preface
  (defun my--ivy-is-directory-p ()
      (and
       (> ivy--length 0)
       (not (string= (ivy-state-current ivy-last) "./"))
       (not (null (ivy-expand-file-if-directory (ivy-state-current ivy-last))))))

  (defun my--enter-directory-or-insert ()
    (interactive)
    (if (my--ivy-is-directory-p)
        (counsel-down-directory)
      (progn
        (let ((last-input (ivy--input)))
          (ivy-insert-current)
          (when (string= last-input (ivy--input))
            (ivy-call))))))

  (defun my--ivy-dired ()
    (interactive)
    (if ivy--directory
        (ivy-quit-and-run
          (dired ivy--directory)
          (when (re-search-forward
                 (regexp-quote
                  (substring ivy--current 0 -1)) nil t)
            (goto-char (match-beginning 0))))
      (user-error
       "Not completing files currently")))
  :bind
  ("C-x C-r" . ivy-resume)
  ("C-x C-b" . ivy-switch-buffer)
  (:map ivy-minibuffer-map
        ("M-RET" . ivy-immediate-done)
        ("C-z" . ivy-dispatching-done)
        ("C-w" . ivy-yank-word)
        ("C-'" . ivy-avy)
        ("C-:" . my-ivy-dired)
        ("<left>" . counsel-up-directory)
        ("<backtab>" . counsel-up-directory)
        ("<right>" . my--enter-directory-or-insert)
        ("TAB" . my--enter-directory-or-insert))
  :custom
  (enable-recursive-minibuffers t)
  (ivy-height 15)
  (ivy-fixed-height-minibuffer t)
  (ivy-count-format "(%d/%d) ")
  (ivy-use-virtual-buffers t)
  (ivy-virtual-abbreviate 'full)
  (ivy-initial-inputs-alist nil)
  (ivy-use-selectable-prompt t)
  (ivy-on-del-error-function nil)
  (ivy-re-builders-alist
   '((t . ivy--regex-ignore-order)))
  :config
  (ivy-mode 1)
  (minibuffer-depth-indicate-mode 1))
#+END_SRC

With ivy one can use =C-M-n / C-M-p= to preview the selection.

#+BEGIN_SRC emacs-lisp
(use-package ivy-rich
  :demand t
  :after counsel
  :custom
  (ivy-rich-parse-remote-buffer nil)
  (ivy-rich-path-style 'abbrev)
  :config
  (ivy-rich-mode 1))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package ivy-hydra
  :after (ivy hydra))
#+END_SRC

*** TODO better keys in the ivy minibuffer
- left/right select dirs
- tab show actions
https://oremacs.com/swiper/#key-bindings
https://github.com/abo-abo/oremacs/blob/github/modes/ora-ivy.el

** Counsel

#+BEGIN_SRC emacs-lisp
(unbind-key "C-x f")

(use-package counsel
  :demand t
  :after ivy
  :bind
  ("C-x f" . counsel-fzf)
  ("C-h F" . counsel-faces)
  (:map read-expression-map
        ("C-r" . counsel-expression-history))
  (:map minibuffer-local-map
        ("C-r" . counsel-minibuffer-history))
  :custom
  (counsel-find-file-at-point t)
  ;; Use rg as backend for counsel-git
  (counsel-git-cmd "rg -S --files")
  ;; max preview and follow symlinks
  (counsel-rg-base-command "rg --max-columns 160 --smart-case --no-heading --line-number --follow --color never %s .")
  ;; use rg instad of grep
  (counsel-grep-base-command "rg --max-columns 160 --smart-case --no-heading --line-number --color never  %s %s")
  :config
  (counsel-mode 1)
  (eval-after-load "org"
    (lambda ()
     (setq counsel-org-goto-display-style 'path
           counsel-org-goto-separator " / "
           counsel-org-goto-face-style 'org
           org-goto-interface 'outline-path-completion
           org-outline-path-complete-in-steps nil)

     (bind-key "C-c c" #'counsel-org-capture my-key-map)
     (bind-keys :map org-mode-map
                ("C-c C-j" . counsel-org-goto)
                ("C-u C-c C-j" . counsel-org-goto-all)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package smex
  :after counsel
  :commands smex
  :custom
  (smex-save-file (expand-file-name "smex-items" my-private-conf-dir))
  (smex-history-length 50))
#+END_SRC

** Swiper

#+BEGIN_SRC emacs-lisp
(use-package swiper
  :demand t
  :after ivy
  :bind
  ([remap isearch-forward] . swiper)
  ([remap isearch-backward] . swiper)
  :custom
  (swiper-action-recenter t))
#+END_SRC

*** TODO better colors for the match

** Imenu

#+BEGIN_SRC emacs-lisp
(use-package imenu
  :ensure nil
  :hook
  (imenu-after-jump . recenter)
  :bind
  ("M-i" . imenu))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package imenu-anywhere
  :bind
  ("M-I" . ivy-imenu-anywhere))
#+END_SRC

** Xref

#+BEGIN_SRC emacs-lisp
(use-package ivy-xref
  :after (ivy xref)
  :commands ivy-xref-show-xrefs
  :init
  (setq xref-show-xrefs-function #'ivy-xref-show-xrefs))
#+END_SRC

** Windows (=C-c w=)                                                   :wip:
*** Overview

| Key         | Description                          | Function      |
|-------------+--------------------------------------+---------------|
| =C-c left=  | Undo changes in window configuration | =winner-undo= |
| =C-c right= | Redo changes in window configuration | =winner-redo= |
| =C-x o=     | Select window using Avy              | =ace-window=  |
*** Move to the window after split

#+BEGIN_SRC emacs-lisp
(defun my-split-window-horizontally-and-move ()
  (interactive)
  (split-window-horizontally)
  (other-window 1))

(defun my-split-window-vertically-and-move ()
  (interactive)
  (split-window-vertically)
  (other-window 1))

(bind-key "C-x 2" #'my-split-window-vertically-and-move my-key-map)
(bind-key "C-x 3" #'my-split-window-horizontally-and-move my-key-map)
#+END_SRC

*** Selecting windows
**** By number

#+BEGIN_SRC emacs-lisp
(use-package winum
  :demand t
  :custom
  (winum-scope 'frame-local)
  :bind (:map winum-keymap
      ("C-`" . winum-select-window-by-number)
      ("M-0" . winum-select-window-0-or-10)
      ("M-1" . winum-select-window-1)
      ("M-2" . winum-select-window-2)
      ("M-3" . winum-select-window-3)
      ("M-4" . winum-select-window-4)
      ("M-5" . winum-select-window-5)
      ("M-6" . winum-select-window-6)
      ("M-7" . winum-select-window-7)
      ("M-8" . winum-select-window-8)
      ("M-9" . winum-select-window-9))
   :config
   (winum-mode))
#+END_SRC

**** Other window, previous on =C-,= and =C-.=

#+BEGIN_SRC emacs-lisp
(defun prev-window ()
  (interactive)
  (other-window -1))

(bind-key "C-," #'prev-window my-key-map)
(bind-key "C-." #'other-window my-key-map)
#+END_SRC

*** Save window layout stack using the =winner-mode=

This will allow to go back/fort between window layouts.

#+BEGIN_SRC emacs-lisp
(use-package winner
  :demand t
  :config
  (winner-mode 1))
#+END_SRC

*** Jump between windows

Use [[https://github.com/abo-abo/ace-window][ace-window]] to switch between windows using =C-x o= instead of the default
=other-window= command.

#+BEGIN_SRC emacs-lisp
(use-package ace-window
  :custom
  (aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
  (aw-dispatch-always nil)
  (aw-dispatch-alist
   '((?x aw-delete-window     "Delete Window")
	   (?S aw-swap-window       "Swap Windows")
	   (?m aw-maximize-window   "Maximize Window")
     (?M aw-move-window       "Move Window")
	   (?c aw-copy-window       "Copy Window")
	   (?= aw-split-window-fair "Split Fair Window")
	   (?- aw-split-window-vert "Split Vert Window")
	   (?| aw-split-window-horz "Split Horz Window")
	   (?? aw-show-dispatch-help)))
  :config
  (set-face-attribute 'aw-leading-char-face nil :weight 'bold)
  :bind
  ("C-x o" . ace-window))
#+END_SRC
*** Rotate layouts

#+BEGIN_SRC emacs-lisp
(use-package rotate
  :commands (rotate-layout rotate-window))
#+END_SRC

*** Setup =C-c w= micro state                                       :hydra:
**** Functions
Define a function to [[https://gist.github.com/3402786][maximize window]].

#+BEGIN_SRC emacs-lisp
(defun my-maximize-window ()
  (interactive)
  (if (and (= 1 (length (window-list)))
           (assoc ?_ register-alist))
      (jump-to-register ?_)
    (progn
      (window-configuration-to-register ?_)
      (delete-other-windows))))
#+END_SRC

**** Hydra

#+BEGIN_SRC emacs-lisp
(defhydra hydra-window (:hint nil)
   ("<left>" windmove-left "left" :column "Select")
   ("<down>" windmove-down "down"  :column "Select")
   ("<up>" windmove-up "up" :column "Select")
   ("<right>" windmove-right "right" :column "Select")
   ("S-<left>" shrink-window-horizontally "shrink left" :column "Resize")
   ("S-<down>" enlarge-window "enlarge right" :column "Resize")
   ("S-<up>" shrink-window "shrink up" :column "Resize")
   ("S-<right>" enlarge-window-horizontally "enlarge down" :column "Resize")
   ("a" ace-window "ace window" :color blue)
   ("|" my-split-window-horizontally-and-move "split horizontal" :column "Layout")
   ("-" my-split-window-vertically-and-move "split vertical" :column "Layout")
   ("s" (lambda ()
          (interactive)
          (ace-window 4)
          (add-hook 'ace-window-end-once-hook
                    'hydra-window/body)) "swap" :column "Layout")
   ("d" kill-buffer-and-window "close" :color blue :column "Other")
   ("D" ace-delete-window "ace close" :column "Other")
   ("t" crux-transpose-windows "transpose" :column "Layout")
   ("m" my-maximize-window "maximize" :color blue :column "Layout")
   ("b" balance-windows-area "balance" :column "Layout")
   ("r" rotate-layout "rotate" :column "Layout")
   ("C-<left>" (progn
          (winner-undo)
          (setq this-command 'winner-undo)) "undo" :column "Layout")
   ("C-<right>" winner-redo "redo" :column "Layout")
   ("q" nil "quit" :column "Other" :color blue))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(bind-key "C-c w" 'hydra-window/body my-key-map)
#+END_SRC
*** TODO move windows (like spacemacs)
** Go to (=M-G=)                                                       :wip:
*** Setup Avy

This allows to quickly jump around in the buffer. The way it is setup is by
remapping the =M-g= to a hydra that calls various [[https://github.com/abo-abo/avy][avy]] functions.

#+BEGIN_SRC emacs-lisp
(unbind-key "M-G")
(unbind-key "M-g")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun my-zap-to-char (pt)
  "Kill from point to PT."
  (if (> pt (point))
      (kill-region (point) (+ pt 1))
    (kill-region (- pt 1) (point))))

(defun my-avy-goto-char (arg)
  (interactive "P")
  (if arg
      (call-interactively 'avy-goto-char)
    (call-interactively 'avy-goto-char-in-line)))

(use-package avy
  :bind
  ("M-g" . my-avy-goto-char)
  ("M-l" . avy-goto-line)
  ("M-L" . avy-goto-end-of-line)
  :custom
  (avy-single-candidate-jump t)
  :config
  (add-to-list 'avy-dispatch-alist '(?Z . my-zap-to-char))
  (avy-setup-default)
  (set-face-attribute 'avy-lead-face-0 nil :foreground "black"))
#+END_SRC

*** Setup =M-G= micro state                                         :hydra:

#+BEGIN_SRC emacs-lisp
(defhydra hydra-goto (:hint nil :color blue)
  ("c" avy-goto-char "char" :column "Char")
  ("w" avy-goto-word-1 "word" :column "word")
  ("W" avy-goto-word-0 "Word")
  ("g" goto-line "line by number" :column "Line")
  ("l" avy-goto-line "line" :column "Line")
  ("L" avy-goto-end-of-line "line end")
  ("m" avy-move-line "move line" :column "Edit")
  ("M" avy-move-region "move region" :column "Edit")
  ("k" avy-kill-whole-line "kill line" :column "Edit")
  ("K" avy-kill-region "kill region" :column "Edit")
  ("y" avy-copy-line "copy line" :column "Edit")
  ("Y" avy-copy-region "copy region" :column "Edit")
  ("q" nil))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(bind-key "M-G" #'hydra-goto/body my-key-map)
#+END_SRC

*** TODO next / previous error
*** TODO next / previous spelling problem
** Buffers (=C-c b=)                                                   :wip:
*** Functions

#+BEGIN_SRC emacs-lisp
(eval-and-compile
  (defun my-new-empty-buffer ()
    "Create a new buffer called untitled(<n>)."

    (interactive)
    (let ((newbuf (generate-new-buffer "untitled")))
      (with-current-buffer newbuf
        (setq-local buffer-offer-save t))
      (switch-to-buffer newbuf nil 'force-same-window)))

  (defun my-switch-to-messages-buffer (&optional arg)
    "Switch to the `*Messages*' buffer. If prefix argument ARG is
given, switch to it in an other, possibly new window."

    (interactive "P")
    (with-current-buffer (messages-buffer)
      (goto-char (point-max))
      (if arg
          (switch-to-buffer-other-window (current-buffer))
        (switch-to-buffer (current-buffer)))))

(defun my-switch-to-scratch-buffer (&optional arg)
  "Switch to the `*scratch*' buffer, creating it first if needed.
If prefix argument ARG is given, switch to it in an other,
possibly new window."

  (interactive "P")
  (let ((exists (get-buffer "*scratch*")))
    (if arg
        (switch-to-buffer-other-window (get-buffer-create "*scratch*"))
      (switch-to-buffer (get-buffer-create "*scratch*")))))

(defun my-kill-buffer-and-window ()
  (interactive)
  (if (> (count-windows) 1)
      (kill-buffer-and-window)
    (kill-buffer))))
#+END_SRC

*** Setup =C-c b= micro state                                       :hydra:

#+BEGIN_SRC emacs-lisp
(defhydra hydra-buffers (:hint nil)
  ("n" next-buffer "next" :column "Local")
  ("p" previous-buffer "previous" :column "Local")
  ("k" kill-this-buffer "kill" :column "Local")
  ("x" my-kill-buffer-and-window "close" :column "Local")
  ("R" revert-buffer "revert" :column "Local")
  ("f" (crux-with-region-or-buffer indent-region) "format" :column "Local")
  ("F" my-reformat-buffer "reformat" :column "Local")
  ("e" erase-buffer "erase" :column "Local")
  ("b" ivy-switch-buffer "list" :exit t :column "Other")
  ("N" my-new-empty-buffer "new" :exit t :column "Other")
  ("m" my-switch-to-messages-buffer "switch to messages" :exit t :column "Other")
  ("s" my-switch-to-scratch-buffer "switch to scratch" :exit t :column "Other")
  ("c" ispell-buffer "check spelling" :exit t :column "Other")
  ("i" ibuffer "ibuffer" :exit t :column "Other"))
#+END_SRC

*** Binding

#+BEGIN_SRC emacs-lisp
(bind-key "C-c b" 'hydra-buffers/body my-key-map)
(bind-key "C-x C-k" 'kill-current-buffer my-key-map)
(bind-key "C-x C-S-k" 'my-kill-buffer-and-window my-key-map)
(bind-key "C-x K" 'my-kill-buffer-and-window my-key-map)
#+END_SRC

** TODO pgup/pgdown go to the same location
** TODO Go to matching paren
** Fine grain navigation using syntax rather than words

Use same syntax for moving back and forth, and deleting a =word=.

#+BEGIN_SRC emacs-lisp
(bind-key "M-f" #'forward-same-syntax my-key-map)
(bind-key "M-b" #'backward-same-syntax my-key-map)
(bind-key "M-d" #'my-kill-synax my-key-map)
#+END_SRC

The =shift= modifier will resume the original functionality.

#+BEGIN_SRC emacs-lisp
(bind-key "M-F" #'forward-word my-key-map)
(bind-key "M-B" #'backward-word my-key-map)
(bind-key "M-D" #'kill-word)
#+END_SRC

** Highlight symbols (=M-*=)

#+BEGIN_SRC emacs-lisp
(defun my-swiper-at-point (initial-input)
  (interactive (list (thing-at-point 'symbol)))
  (swiper initial-input))

(bind-key "M-*" 'my-swiper-at-point my-key-map)
#+END_SRC

** TODO ace-link
- https://github.com/abo-abo/ace-link
** =C-a= / =home= to the beginning

#+BEGIN_SRC emacs-lisp
(bind-key "C-a" #'crux-move-beginning-of-line)
(bind-key "<home>" #'crux-move-beginning-of-line)
#+END_SRC

*** TODO text objects
- https://github.com/clemera/objed
** Bookmarks

| Key       | Description            | Function                  |
|-----------+------------------------+---------------------------|
| =C-x r l= | List bookmarks         | =bookmark-list=           |
| =C-x r b= | Jump to a bookmark     | =bookmark-jump=           |
| =C-x r m= | Set bookmark           | =bookmark-set=            |

#+BEGIN_SRC emacs-lisp
(use-package bookmark
  :custom
  (bookmark-default-file (expand-file-name "bookmarks" my-private-conf-dir))
  (bookmark-save-flag 1))
#+END_SRC

** Move back and forth
*** Increase the ring size

#+BEGIN_SRC emacs-lisp
(setq global-mark-ring-max 32
      mark-ring-max 32)
#+END_SRC

*** Flash the line

#+BEGIN_SRC emacs-lisp
(use-package nav-flash
  :commands nav-flash-show)
#+END_SRC

*** Back button

#+BEGIN_SRC emacs-lisp
(use-package back-button
  :bind
  ("C-x C-@" . back-button-global)
  ("C-x SPC" . back-button-local)
  :config
  (back-button-mode 1))
#+END_SRC

*** TODO can this be actually a hydra?
* Search and replace
** Replace

#+BEGIN_SRC emacs-lisp
(use-package anzu
  :defer 1
  :diminish
  :bind
  ([remap query-replace] . anzu-query-replace)
  ([remap query-replace-regexp] . anzu-query-replace-regexp)
  :custom
  (anzu-replace-to-string-separator " → ")
  :config
  (global-anzu-mode 1))
#+END_SRC

* Toggles (=C-c t=)
** Setup =C-c t= micro state                                         :hydra:

#+BEGIN_SRC emacs-lisp
(defhydra hydra-toggle (:color blue :hint nil)
  "
[_a_] abbrev-mode:       %`abbrev-mode
[_d_] debug-on-error:    %`debug-on-error
[_f_] auto-fill-mode:    %`auto-fill-function
[_t_] truncate-lines:    %`truncate-lines
[_w_] whitespace-mode:   %`whitespace-mode
[_l_] org link display:  %`org-descriptive-links
[_s_] spell check:       %`flyspell-mode
[_S_] syntax:            %`font-lock-mode
"
  ("a" abbrev-mode)
  ("d" toggle-debug-on-error)
  ("f" auto-fill-mode)
  ("t" toggle-truncate-lines)
  ("w" whitespace-mode)
  ("l" org-toggle-link-display)
  ("s" flyspell-mode)
  ("S" font-lock-mode)
  ("q" nil "quit"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(bind-key "C-c t" 'hydra-toggle/body my-key-map)
#+END_SRC

*** TODO use pretty hydra
https://github.com/jerrypnz/major-mode-hydra.el

* TODO Mouse
* Projects
** Projectile configuration (=C-c p=)

#+BEGIN_SRC emacs-lisp
(use-package projectile
  :defer 1
  :diminish "P"
  :bind-keymap
  ("C-c p" . projectile-command-map)
  :bind
  ("C-c /" . my-search-in-project-or-dir-empty)
  (:map projectile-command-map
        ("C-k" . my-kill-non-project-buffers)
        ("/" . my-search-in-project-or-dir-empty)
        ("?" . my-search-in-project-or-dir))
  :custom
  (projectile-indexing-method 'alien)
  (projectile-completion-system 'ivy)
  (projectile-project-search-path my-projects-search-path)
  ;; enable caching otherwise it will be slow for large projects
  (projectile-enable-caching t)
  (projectile-generic-command "fd . -0")
  (projectile-git-command "fd . -0")
  (projectile-sort-order 'recently-active)
  (projectile-cache-file (concat my-private-conf-dir "projectile.cache"))
  :preface
  (defun my-search-in-project-or-dir (initial-input &optional use-current-dir)
    "Search using `counsel-rg' from the project root for INITIAL-INPUT.
     If there is no project root, or if the prefix argument
     USE-CURRENT-DIR is set, then search from the current
     directory instead."

    (interactive (list (thing-at-point 'symbol)
                       current-prefix-arg))

    (let ((current-prefix-arg)
          (ignored
           (mapconcat
            (lambda (i)
              (concat "--glob "
                      (shell-quote-argument (concat "!" i))
                      " "))
            (append (projectile-ignored-files-rel)
                    (projectile-ignored-directories-rel))
            ""))
          (dir (if (equal use-current-dir nil)
                   ;; no prefix: try to use project root
                   (condition-case _err
                       (projectile-project-root)
                     (error default-directory))
                 ;; with prefix use the current directory
                 default-directory))
          (prompt (if (null use-current-dir)
                      (projectile-prepend-project-name "rg ")
                    (format "%s rg " default-directory))))
      (counsel-rg initial-input dir ignored prompt)))

  (defun my-search-in-project-or-dir-empty (&optional use-current-dir)
    "Like my-search-in-project-or-dir with no initial input."
    (interactive "P")
    (my-search-in-project-or-dir "" use-current-dir))

  ;; http://emacs.stackexchange.com/a/10187/115
  (defun my-kill-non-project-buffers (&optional kill-special)
    "Kill buffers that do not belong to a `projectile' project.
     With prefix argument, also kill the special buffers."
    (interactive "P")
    (let ((bufs (buffer-list (selected-frame))))
      (dolist (buf bufs)
        (with-current-buffer buf
          (let ((buf-name (buffer-name buf)))
            (when (or (null (projectile-project-p))
                      (and kill-special
                           (string-match "^\*" buf-name)))
              ;; Preserve buffers with names starting with *scratch or *Messages
              (unless (string-match "^\\*\\(\\scratch\\|Messages\\)" buf-name)
                (message "Killing buffer %s" buf-name)
                (kill-buffer buf))))))))
  :config
  (projectile-mode))
#+END_SRC

It is good to run the

#+BEGIN_SRC emacs-lisp
(projectile-discover-projects-in-search-path)
#+END_SRC

to index the projects in the search path.

*** Counsel integration

#+BEGIN_SRC emacs-lisp
(use-package counsel-projectile
  :after (projectile counsel)
  :config
  (counsel-projectile-mode))
#+END_SRC

*** Notes

Ivy's call is like helm's follow-mode.
** TODO org-projectile
* Packages
** TODO this section should be removed and the packages moved accrodingly
** ibuffers

#+BEGIN_SRC emacs-lisp
(use-package ibuffer
  :bind
  ([remap list-buffers] . ibuffer))
#+END_SRC

**** TODO hydra
- https://github.com/abo-abo/hydra#the-impressive-looking-one
** which-key

#+BEGIN_SRC emacs-lisp
(use-package which-key
  :demand t
  :diminish
  :custom
  (which-key-idle-delay 0.3)
  :config
  (which-key-mode))
#+END_SRC

** dired
*** Settings

Auto refresh dired
#+BEGIN_SRC emacs-lisp
(use-package dired
  :demand t
  :ensure nil
  :bind (:prefix "C-c d"
         :prefix-map my-dired-map
         ("j" . dired-jump)
         ("J" . dired-jump-other-window))
  :custom
  ;; file sizes in human-readable units (KB, MB, etc)
  (dired-listing-switches "-alh"))
#+END_SRC

*** TODO double pane setup
https://github.com/jwiegley/dot-emacs/blob/master/init.el#L1027
*** TODO dired toggle
https://github.com/jwiegley/dot-emacs/blob/master/init.el#L1162
*** TODO diredx
https://github.com/jwiegley/dot-emacs/blob/master/init.el#L1172
*** TODO hydra
** info
*** TODO hydra
** diff

#+BEGIN_SRC emacs-lisp
(use-package ediff
  :config
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
  (setq-default ediff-highlight-all-diffs 'nil)
  (setq ediff-diff-options "-w"))
#+END_SRC

*** TODO keybinding
https://github.com/jwiegley/dot-emacs/blob/master/init.el#L1268

** TODO kbd macros
** View large files
#+BEGIN_SRC emacs-lisp
(use-package vlf
  :custom
  (large-file-warning-threshold (* 64 1024 1024))
  :ensure t
  :config
  (require 'vlf-setup))
#+END_SRC
** PDF tools

#+BEGIN_SRC emacs-lisp
(use-package pdf-tools
  :mode (("\\.pdf\\'" . pdf-view-mode))
  :config
  (pdf-tools-install))
#+END_SRC

* Helpers
** config.org and init.el helpers

#+BEGIN_SRC emacs-lisp
(use-package restart-emacs
  :preface
  (defun my-reload-config-file ()
    (interactive)
    (let* ((init-file (emacs-path my-config-file))
           (init-file-buffer (get-file-buffer init-file)))
      (when (and init-file-buffer
                 (buffer-modified-p init-file-buffer)
                 (y-or-n-p (format "Save file %s? " init-file)))
        (with-current-buffer init-file-buffer
          (save-buffer)))
      (org-babel-load-file init-file)))

  (defun my-find-config-file ()
    (interactive)
    (find-file my-config-file))

  (defun my-find-config-dir ()
    (interactive)
    (find-file (file-name-directory my-config-file)))

  (defun my-restart-emacs-with-debug ()
    (interactive)
    (restart-emacs '("--debug-init")))

  :bind (:prefix "C-c e"
         :prefix-map my-emacs-helper-map
         :prefix-docstring "Emacs init.el related"
         ("d" . my-find-config-dir)
         ("e" . my-find-config-file)
         ("g" . my-dotfiles-magit)
         ("r" . my-reload-config-file)
         ("D" . my-restart-emacs-with-debug)
         ("R" . restart-emacs))
  :init
  (which-key-add-key-based-replacements "C-c e" "Emacs")
  (which-key-add-key-based-replacements "C-c e d" "Find .emacs.d")
  (which-key-add-key-based-replacements "C-c e e" "Find config.el")
  (which-key-add-key-based-replacements "C-c e g" "magit")
  (which-key-add-key-based-replacements "C-c e r" "reload config")
  (which-key-add-key-based-replacements "C-c e D" "restart Emacs with debug")
  (which-key-add-key-based-replacements "C-c e R" "restart Emacs")
  :commands restart-emacs)
#+END_SRC

* Version control
** Sort buffers in ibuffer based on git

#+BEGIN_SRC emacs-lisp
(use-package ibuffer-vc
  :hook
  (ibuffer . (lambda ()
               (ibuffer-vc-set-filter-groups-by-vc-root)
               (unless (eq ibuffer-sorting-mode 'alphabetic)
                 (ibuffer-do-sort-by-alphabetic)))))
#+END_SRC

** Magit

#+BEGIN_SRC emacs-lisp
(use-package magit
  :custom
  (magit-display-buffer-function 'magit-display-buffer-fullframe-status-v1 "Enable fullscreen")
  (magit-completing-read-function 'ivy-completing-read)
  :bind
  ("C-c g" . magit-status))
#+END_SRC

** Highlight chnages in files

#+BEGIN_SRC emacs-lisp
(use-package diff-hl
  :hook
  ((prog-mode . diff-hl-mode)
   (prog-mode . diff-hl-margin-mode)
   (org-mode . diff-hl-mode)
   (org-mode . diff-hl-margin-mode)
   (dired-mode . diff-hl-dired-mode))
  :config
  (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh))
#+END_SRC

** Support for my local dot-file config

I use git to version my dot files. While there are many options for managing
them such as [[https://github.com/RichiH/vcsh][vcsh]], I prefer the simplest possible, just using git and nothing
else. The trick is to separate work tree and git directory. While this work
well, magit does not understand this and has to have the relevant =--work-tree=
and =--git-dir= options explicitly set. For this I define a new function
=my-dotfiles-magit= which tries to do that.

#+BEGIN_SRC emacs-lisp
(defconst my-dotfiles-git-dir (expand-file-name "~/.dotfiles"))

(defun my--dotfiles-remove-magit-config (&optional kill)
  (setq magit-git-global-arguments
        (remove (format "--work-tree=%s" (getenv "HOME")) magit-git-global-arguments))
  (setq magit-git-global-arguments
        (remove (format "--git-dir=%s" my-dotfiles-git-dir) magit-git-global-arguments))
  (advice-remove 'magit-mode-bury-buffer #'my--dotfiles-remove-magit-config))

(defun my-dotfiles-magit ()
  (interactive)
  (when (and (boundp 'magit-git-global-arguments)
             (file-exists-p my-dotfiles-git-dir))
    (let ((home (getenv "HOME")))
      (add-to-list 'magit-git-global-arguments
                   (format "--work-tree=%s" home))
      (add-to-list 'magit-git-global-arguments
                   (format "--git-dir=%s" my-dotfiles-git-dir))
      (advice-add 'magit-mode-bury-buffer :after #'my--dotfiles-remove-magit-config)
      (magit-status-setup-buffer home))))
#+END_SRC
*** TODO allow the =dotfiles-magit= work even if magit have not been initialized yet
** TODO magit-todo

* Org
** Default setup

#+BEGIN_SRC emacs-lisp
(use-package org
  :demand t
  ;; org is installed from init.el
  :ensure nil
  :mode
  ("\\.org$" . org-mode)
  :hook
  (org-mode . flyspell-mode)
  :custom
  (org-agenda-files '("~/Notes/Journal"))
  (org-blank-before-new-entry '(((heading .  t) (plain-list-item . t))))
  (org-capture-templates
     '(("t" "Todo"         entry (file+headline "~/Notes/Journal/TODO.org" "INBOX")  "* TODO %?\ncaptured on: %U\nfrom: %a\n%i")
       ("n" "Note"         entry (file+headline "~/Notes/Journal/Notes.org" "Notes") "* %?\ncaptured on: %U\nfrom: %a\n%i")
       ("j" "Journal"      entry (file+datetree "~/Notes/Journal/Journal.org")    "* %?\n%i")
       ("J" "Work Journal" entry (file+datetree "~/Notes/Journal/Work.org")  "* %?\n%i")))
  (org-catch-invisible-edits 'smart)
  (org-confirm-babel-evaluate nil)
  (org-default-notes-file "~/Notes/Journal/Notes.org")
  (org-directory "~/Notes")
  (org-id-link-to-org-use-id 'create-if-interactive)
  (org-image-actual-width nil)
  (org-imenu-depth 8)
  (org-latex-prefer-user-labels t)
  (org-log-done t)
  (org-log-into-drawer t)
  (org-log-reschedule 'time)
  (org-refile-active-region-within-subtree t)
  (org-refile-allow-creating-parent-nodes 'confirm)
  (org-refile-targets '((nil :maxlevel . 6) (org-agenda-files :maxlevel . 7)))
  (org-refile-use-cache t)
  (org-refile-use-outline-path t)
  (org-src-fontify-natively t)
  (org-src-preserve-indentation t)
  (org-src-tab-acts-natively t)
  (org-startup-with-inline-images t)
  (org-startup-indented t)
  (org-special-ctrl-a/e t)
  (org-todo-keywords '((sequence "TODO(t)" "WAIT(w@/!)" "|" "DONE(d!)" "CANCELED(c@)")))
  (org-show-context-detail
   '((agenda . local)
     (bookmark-jump . lineage)
     (isearch . tree) ; I want to see more info when looking at tree
     (default . ancestors)))
  :bind
  (:map org-mode-map
        ("C-a" . org-beginning-of-line)
        ("C-e" . org-end-of-line))
  :config
  (set-face-attribute 'org-todo nil :weight 'bold))
#+END_SRC

** Better appearance

#+BEGIN_SRC emacs-lisp
(use-package org-bullets
  :custom
  (org-bullets-bullet-list '("•"))
  (org-ellipsis "↴")
  :hook
  (org-mode . org-bullets-mode))
#+END_SRC

** Yasnippet support

From [[https://orgmode.org/worg/org-faq.html#YASnippet][org-manual]]:
#+begin_quote
The way Org-mode binds the TAB key (binding to [tab] instead of \t) overrules yasnippets' access to this key.
#+end_quote

The following is the _official_ way to fix it:

#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook
          (lambda ()
            (eval-after-load "yas"
              (lambda ()
                (make-variable-buffer-local 'yas/trigger-key)
                (setq yas/trigger-key [tab])
                (add-to-list 'org-tab-first-hook 'yas-expand)
                (define-key yas-keymap [tab] 'yas-next-field)))))
#+END_SRC

** Babel

#+BEGIN_SRC emacs-lisp
(use-package ob
  :ensure nil
  :after org
  :commands org-babel-load-languages
  :custom
  (org-babel-load-languages
   '((shell . t)
     (emacs-lisp . t)))
  :config
  (defun my--org-babel-do-load-languages ()
    "Load all the languages declared in `org-babel-load-languages'."
    (org-babel-do-load-languages 'org-babel-load-languages
                                 org-babel-load-languages))

  (defun org-babel-remove-result-buffer ()
    "Remove results from every code block in buffer."
    (interactive)
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward org-babel-src-block-regexp nil t)
        (org-babel-remove-result))))

  (add-hook 'org-mode-hook 'my--org-babel-do-load-languages))
#+END_SRC

*** TODO Fix redisplay of inline images after a code block evaluation.

#+BEGIN_SRC emacs-lisp :tangle no
(add-hook 'org-babel-after-execute-hook 'spacemacs/ob-fix-inline-images)
#+END_SRC
** [[https://github.com/jkitchin/org-ref/][org-ref]]

#+BEGIN_SRC emacs-lisp
(use-package org-ref
  :after (org ivy)
  :commands org-ref-ivy-cite
  :custom
  (org-ref-bibliography-notes my-bibliography-notes-file)
  (org-ref-default-bibliography (list my-bibliography-bib-file))
  (org-ref-pdf-directory (concat my-bibliography-path "/"))
  (org-ref-note-title-format
   "* TODO %a (%y): %t
 :PROPERTIES:
 :Custom_ID: %k
 :Book: %b
 :URL: %U
 :NOTER_DOCUMENT: %f
 :END:
")
  :config
  (eval-after-load "reftex"
    (lambda ()
      (reftex-default-bibliography org-ref-default-bibliography))))
#+END_SRC

(setq org-latex-pdf-process (list "latexmk -shell-escape -bibtex -f -pdf %f"))

#+BEGIN_SRC emacs-lisp
(use-package ivy-bibtex
  :after ivy
  :commands ivy-bibtex
  :custom
  (bibtex-completion-bibliography my-bibliography-bib-file)
  (bibtex-completion-library-path my-bibliography-path)
  (bibtex-completion-notes-path my-bibliography-notes-file)
  (bibtex-completion-notes-template-one-file
   "* TODO ${author} (${year}): ${title}
:PROPERTIES:
:Custom_ID: ${=key=}
:Book: ${booktitle}
:URL: ${url}
:NOTER_DOCUMENT: ${file}
:END:
"))
#+END_SRC
** Habits

Tracks habits using [[https://orgmode.org/manual/Tracking-your-habits.html][org-habit]].

#+BEGIN_SRC emacs-lisp
(add-to-list 'org-modules 'org-habit)
(use-package org-habit
  :ensure nil
  :custom
  (org-habit-show-all-today t)
  (org-habit-show-habits-only-for-today t)
  (org-habit-show-done-always-green t)
  (org-habit-graph-column 60)
  (org-habit-preceding-days 28)
  (org-habit-following-days 7))
#+END_SRC


** TODO images
- https://github.com/abo-abo/org-download
** TODO [[https://github.com/alphapapa/org-sticky-header][org-sticky-header]]
** TODO [[https://github.com/bastibe/org-journal][org-journal]]
** TODO org-projectile
** TODO org-present ?
** TODO better refiling
** TODO lazy load
** TODO org-bookmark-heading

For some reason, the default bookmark behavior in org mode is that the bookmark
is not linked to the org-id. This means that if the heading is shifted
somewhere, the bookmark becomes useless! The remedy seems to be using the
package org-bookmark-heading

#+BEGIN_SRC emacs-lisp :tangle no
(use-package org-bookmark-heading
  :ensure t
  :defer t
  :config
  (require 'org-bookmark-heading))
#+END_SRC

* Languages
** General
*** TODO configure flymake
*** Documentation with dash

#+BEGIN_SRC emacs-lisp
(use-package counsel-dash
  :commands counsel-dash counsel-dash-install-docset
  :hook
  (c-mode . (lambda () (setq-local counsel-dash-docsets '("C"))))
  (c++-mode . (lambda () (setq-local counsel-dash-docsets '("C++"))))
  (emacs-lisp-mode . (lambda () (setq-local counsel-dash-docsets '("Emacs Lisp"))))
  (java-mode . (lambda () (setq-local counsel-dash-docsets '("Java"))))
  (ess-mode . (lambda () (setq-local counsel-dash-docsets '("R"))))
  (inferior-ess-mode . (lambda () (setq-local counsel-dash-docsets '("R"))))
  (rust-mode . (lambda () (setq-local counsel-dash-docsets '("Rust"))))
  (scala-mode . (lambda () (setq-local counsel-dash-docsets '("Scala"))))
  :config
  ;; it does not work with custom from some reason
  (setq counsel-dash-docsets-path (expand-file-name "~/.config/dash-docset")))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun my-dash-docsets-install ()
  (interactive)
  (mapc (lambda (docset)
          (unless (dash-docs-docset-installed-p docset)
            (counsel-dash-install-docset docset)))
        my-dash-docsets))
#+END_SRC

*** Documentation with eldoc

#+BEGIN_SRC emacs-lisp
(use-package eldoc
  :ensure nil
  :diminish (eldoc-mode . "ELD")
  :commands eldoc-mode)
#+END_SRC

*** TODO LSP using eglot

#+BEGIN_SRC emacs-lisp
(use-package eglot
  :commands eglot
  :preface
  (defun my--projectile-project-find-function (dir)
    (let* ((root (projectile-project-root dir)))
      (and root (cons 'transient root))))
  :hook
  ((c-mode c++-mode) . eglot-ensure)
  :config
  (with-eval-after-load 'project
    (add-to-list 'project-find-functions 'my--projectile-project-find-function))
  (setq company-backends
        (cons 'company-capf
              (remove 'company-capf company-backends))))
#+END_SRC
*** TODO Debugger

The gud debugger is quite nice for gdb.
How to debug Java/Scala/Rust?
*** Interpreters
**** Create termino for comint with support for ANSI color codes

#+BEGIN_SRC sh :tangle no
cat > /tmp/dumb-emacs-ansi.ti << EOF
dumb-emacs-ansi|Emacs dumb terminal with ANSI color codes,
    am,
    colors#8, it#8, ncv#13, pairs#64,
    bold=\E[1m, cud1=^J, ht=^I, ind=^J, op=\E[39;49m,
    ritm=\E[23m, rmul=\E[24m, setab=\E[4%p1%dm,
    setaf=\E[3%p1%dm, sgr0=\E[m, sitm=\E[3m, smul=\E[4m,
EOF

tic -x /tmp/dumb-emacs-ansi.ti
rm /tmp/dumb-emacs-ansi.ti
#+END_SRC

**** Make the interpreter work like an interpreter

#+BEGIN_SRC emacs-lisp
(use-package comint
  :defer 2
  :preface
  (defun my-locally-disable-hl-line-mode ()
    "Locally disable global-hl-line-mode"
    (interactive)
    (setq-local global-hl-line-mode nil))

(defun my-comint-clear-buffer ()
  (interactive)
  (let ((comint-buffer-maximum-size 0))
    (comint-truncate-buffer)))
  :ensure nil
  :bind (:map comint-mode-map
              ([up] . comint-previous-matching-input-from-input)
              ([down] . comint-next-matching-input-from-input)
              ("C-k" . kill-line)
              ("C-l" . my-comint-clear-buffer))
  :hook
  (comint-mode . my-locally-disable-hl-line-mode)
  :custom
  (comint-prompt-read-only t)
  (comint-buffer-maximum-size 8192)
  (comint-terminfo-terminal "dumb-emacs-ansi")
  (comint-scroll-to-bottom-on-output 'others)
  (comint-scroll-show-maximum-output t)
  (comint-move-point-for-matching-input 'end-of-line)
  (comint-scroll-to-bottom-on-input 'this))
#+END_SRC
**** TODO do not highlight current line when at the prompt
*** Compilation

#+BEGIN_SRC emacs-lisp
(use-package compile
  :custom
  ;; always save before compiling
  (compilation-ask-about-save nil)
  ;; just kill old compile processes before starting the new one
  (compilation-always-kill t)
  ;; scroll with the compilation output
  ;; set to 'first-error to stop scrolling on first error
  (compilation-scroll-output t))
#+END_SRC

** C/C++
*** TODO completion
https://github.com/MaskRay/ccls/wiki/eglot
*** TODO hierarchy
https://github.com/MaskRay/ccls/wiki/eglot
** TODO Elisp

We set up smartparens above, but when it’s enabled in strict mode for lisps it
really comes into its own. As a refresher, don’t forget about C-( and note that
thanks to universal arguments you can prefix a number which will wrap multiple
s-expressions. e.g. C-2 C-( on a b c will turn it into (a b) c.

It’s well worth studying sp-smartparens-bindings with C-h v to see what else is
enabled. M-<delete> is also incredibly useful.

#+BEGIN_SRC emacs-lisp :tangle no
(add-hook 'emacs-lisp-mode-hook
          (lambda ()
            (setq show-trailing-whitespace t)
            (show-paren-mode)
            (focus-mode)
            (rainbow-mode)
            (prettify-symbols-mode)
            (eldoc-mode)
            (flycheck-mode)
            (yas-minor-mode)
            (company-mode)
            (smartparens-strict-mode)
            (rainbow-delimiters-mode)))
#+END_SRC

** TODO scala
- using ensime?

#+BEGIN_SRC emacs-lisp :tangle no
(sp-local-pair 'scala-mode "(" nil :post-handlers '(("||\n[i]" "RET")))
(sp-local-pair 'scala-mode "{" nil :post-handlers '(("||\n[i]" "RET") ("| " "SPC")))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
(defun sp-restrict-c (sym)
  "Smartparens restriction on `SYM' for C-derived parenthesis."
  (sp-restrict-to-pairs-interactive "{([" sym))

(bind-key "s-<delete>" (sp-restrict-c 'sp-kill-sexp) scala-mode-map)
(bind-key "s-<backspace>" (sp-restrict-c 'sp-backward-kill-sexp) scala-mode-map)
(bind-key "s-<home>" (sp-restrict-c 'sp-beginning-of-sexp) scala-mode-map)
(bind-key "s-<end>" (sp-restrict-c 'sp-end-of-sexp) scala-mode-map)
#+END_SRC

Ever wanted to change a (_.thing) to a { foo => foo.thing } and back? This helps…

#+BEGIN_SRC emacs-lisp :tangle no
(bind-key "s-{" 'sp-rewrap-sexp smartparens-mode-map)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
(require 'ensime-expand-region)

(add-hook 'scala-mode-hook
          (lambda ()
            (show-paren-mode)
            (smartparens-mode)
            (yas-minor-mode)
            (git-gutter-mode)
            (company-mode)
            (ensime-mode)
            (scala-mode:goto-start-of-code)))

#+END_SRC

** R

#+BEGIN_SRC emacs-lisp
(use-package ess
  :mode (("/R/.*\\.q\\'"       . R-mode)
         ("\\.[rR]\\'"         . R-mode)
         ("\\.[rR]nw\\'"       . Rnw-mode)
         ("\\.[sS]nw\\'"       . Snw-mode)
         ("\\.[rR]profile\\'"  . R-mode)
         ("NAMESPACE\\'"       . R-mode)
         ("CITATION\\'"        . R-mode)
         ("\\.Rd\\'"           . Rd-mode))
  :commands R
  :hook (ess-mode . subword-mode)
  :custom
  (ess-default-style 'RStudio)
  (ess-indent-level 4)
  (ess-nuke-trailing-whitespace-p t)
  (ess-tab-complete-in-script t)
  (ess-build-tags-command "system(\"~/bin/rtags.R '%s' '%s'\")")
  (ess-indent-with-fancy-comments nil)
  (ess-R-argument-suffix "=")
  (ess-smart-S-assign-key nil)
  (ess-R-font-lock-keywords '((ess-R-fl-keyword:fun-defs . t)
                              (ess-R-fl-keyword:modifiers . t)
                              (ess-R-fl-keyword:keywords . t)
                              (ess-R-fl-keyword:assign-ops . t)
                              (ess-R-fl-keyword:constants . t)
                              (ess-R-fl-keyword:F&T . t)
                              (ess-fl-keyword:fun-calls . t)
                              (ess-fl-keyword:numbers . t)
                              (ess-fl-keyword:operators)
                              (ess-fl-keyword:delimiters)
                              (ess-fl-keyword:=))))
#+END_SRC

*** Evaluate last function call with =C-x C-e=

#+BEGIN_SRC emacs-lisp
(use-package ess-r-mode
  :preface
  (defun my-r-eval-last-function-call ()
    "Evaluate the last function call (does not work with infix
     notation) The cursor should be poisitioned at the end of the
     call, i.e. after the closing paren."
    (interactive)
    (unless (string= (buffer-substring-no-properties (- (point) 1) (point)) ")")
      (error "Not at the end of a function call"))
    (let ((end (point)))
      (save-excursion
        ;; go to the beginning of the function argument list
        (backward-list)
        ;; go to the beginning of the function name
        (backward-sexp)
        (ess-eval-region (point) end t (format "Eval call to %s" (thing-at-point 'symbol))))))
  :ensure ess
  :bind
  (:map ess-r-mode-map
        ("C-x C-e" . my-r-eval-last-function-call)))
#+END_SRC

*** TODO [[https://github.com/polymode/poly-R][poly-R]]
*** TODO poly-markdown
*** TODO poly-org

** TODO Latex
- auctex
- latexmk
** Config

#+BEGIN_SRC emacs-lisp
(use-package conf-mode
  :mode ("mbsyncrc\\'" "msmtprc\\'" "\\.cnf\\'"
         "\\.ini\\.\\(tmpl\\|sample\\)\\'" "\\.service\\'"))
#+END_SRC

** CSV

#+BEGIN_SRC emacs-lisp
(use-package csv-mode
  :mode "\\.csv\\'"
  :custom
  (csv-separators '("," "	" ";" "|")))
#+END_SRC

** TOML

#+BEGIN_SRC emacs-lisp
(use-package toml-mode
  :mode ("\\.toml\\'" "Cargo.lock\\'"))
#+END_SRC

** YAML

#+BEGIN_SRC emacs-lisp
(use-package yaml-mode
  :mode ("\\.yaml\\'" "\\.yml\\'"))
#+END_SRC

** TODO Markdown
* Applications
** TODO agenda / calendar
** TODO email
** TODO elfeed
- https://github.com/abo-abo/elfeed
* Troubleshooting
** Invalid function =org-preserve-local-variables=

As indicated in [[https://github.com/syl20bnr/spacemacs/issues/11801#issuecomment-451755821][spacemacs/11801]], the problem is in version misalignment which
can be fixed by removing all =org-*/*.elc= files and compiling it again:

#+BEGIN_SRC sh :tangle no
find ~/.emacs.d/elpa/org*/*.elc -print0 | xargs -0 rm
#+END_SRC

And then running the following function

#+BEGIN_SRC emacs-lisp :tangle no
(my-recompile-elpa)
#+END_SRC

** Invalid function =org-outline-overlay-data=

Similar to the above, this time caused by expand region [[https://github.com/syl20bnr/spacemacs/issues/12099][spacemacs/12099]].

#+BEGIN_SRC sh
find ~/.emacs.d/elpa/expand-region*/*.elc -print0 | xargs -0 rm
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
(my-recompile-elpa)
#+END_SRC

** Unable to install a package

In the case a package installation from =(use-package)= fails due to a missing
file on MELPA, it might be due to an outdated local index. Use:

#+BEGIN_SRC emacs-lisp :tangle no
(package-refresh-contents)
#+END_SRC
