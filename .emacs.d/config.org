#+TITLE: Emacs configuration file
#+AUTHOR: Filip Krikava
#+BABEL: :cache yes
#+PROPERTY: header-args :tangle yes
#+STARTUP: overview

* Overview
** TODO descrive the idea behind this configuration
** Micro states

| Key     | Micro state      |
|---------+------------------|
| =C-x w= | Windows          |
| =C-x b= | Buffers          |
| =C-x t= | Toggles          |
| =C-x p= | Projects         |
| =C-c &= | Snippets         |
| =M-g=   | Go to            |
| =M-r=   | Expand region    |
| =M-m=   | Multiple cursors |

** Other keys


* Sources
** TODO clean and describe
- http://wikemacs.org/wiki/Starter_Kits
- https://github.com/technomancy/better-defaults/blob/master/better-defaults.el
- http://www.emacs-bootstrap.com/
- https://github.com/a13/emacs.d/blob/master/README.org
- https://github.com/freetonik/emacs-dotfiles/blob/master/init.org
  - emacs podcast guy configuration
- http://pages.sachachua.com/.emacs.d/Sacha.html
  - the emacs girl configuration
- https://github.com/danielmai/.emacs.d/blob/master/config.org
- https://thb.lt/emacs-cheatsheet/
- https://github.com/abo-abo/awesome-emacs
- https://github.com/redguardtoo/emacs.d
- https://github.com/abo-abo/oremacs
- https://github.com/purcell/emacs.d
- https://github.com/trending/emacs-lisp?since=monthly
- https://melpa.org/#/?sort=downloads&asc=false
- https://github.com/sam217pa/emacs-config/blob/develop/init.el
- https://sam217pa.github.io/2016/10/18/context-dependent-keybindings/
- https://bitbucket.org/holgerschurig/emacsconf/src/74d428aa2f9be88b14a503f6c3a816ae7cd13644/helm.org?at=master&fileviewer=file-view-default
  - just a helm configuration
- http://www.matskjesrud.com/emacs.html
- https://old.reddit.com/r/emacs/comments/bk9k7l/tips_and_tricks_for_r_programming_in_academia/
  - about R
- http://juanjose.garciaripoll.com/blog/emacs-wanderlust-email
  - about wunderlust
[[https://github.com/jwiegley/use-package][use-package
]]
** To check
https://melpa.org/#/rainbow-delimiters
https://github.com/milkypostman/powerline
https://github.com/Fuco1/smartparens

* Basics
** Lexical scoping                                            :experimental:

I like lexical scoping, but not sure if this actually really does anything.

#+BEGIN_SRC emacs-lisp
;;; -*- lexical-binding: t -*-
#+END_SRC

** GC threshold

Allow 128MB between GC cycle (defailt is 780kB). Apparently this should make
some operations faster, although I never tested it.

#+BEGIN_SRC emacs-lisp
(setq gc-cons-threshold (* 128 1024 1024))
#+END_SRC

** Customize file =custom.el=                                          :wip:

Set up the customize file to its own separate file, instead of saving
customize settings in [[file:init.el][init.el]].

*** TODO what to do with the custom file? Keep it, keep it, but not version it or send to /tmp

#+BEGIN_SRC emacs-lisp
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
(load custom-file)
#+END_SRC

** Set up =use-package=

These additional packages add the ability to diminish minor modes from
modeline, and to conveniently bind keys using =:diminish= and =:bind-key=
keywords in =(use-package)=.

#+BEGIN_SRC emacs-lisp
;; :diminish keyword
(use-package diminish :ensure t)

;; :bind keyword
(use-package bind-key :ensure t)
#+END_SRC

** Install hydra

#+BEGIN_SRC emacs-lisp
(use-package hydra :ensure t)
#+END_SRC

** Install smartrep                                           :experimental:

I would prefer to use hydra for all, but it somehow does not work with multiple
cursors.

#+BEGIN_SRC emacs-lisp
(use-package smartrep
  :ensure t
  :custom
  (smartrep-mode-line-string-activated "[SR]")
  ;; no modeline higlighting
  (smartrep-mode-line-active-bg (face-background 'mode-line))
)
#+END_SRC

* Defaults
** Enable some useful functions

These functions are useful so activate them.

#+BEGIN_SRC emacs-lisp
(put 'downcase-region 'disabled nil)
(put 'upcase-region 'disabled nil)
(put 'narrow-to-region 'disabled nil)
(put 'dired-find-alternate-file 'disabled nil)
#+END_SRC

** File backup                                                         :wip:
*** TODO better way to handle backups
*** TODO document how does it exactly work

#+BEGIN_SRC emacs-lisp
(setq
      auto-save-list-file-name           (concat user-emacs-directory "/autosave")
      backup-directory-alist            `((".*" . ,(concat user-emacs-directory "/backups/")))
      ;;auto-save-file-name-transforms    `((".*" ,(concat user-emacs-directory "/auto-save-list/") t))
      version-control                    t
      backup-by-copying                  t
      delete-old-versions                t
      kept-new-versions                  6
      kept-old-versions                  2
      history-length                     1000
      backup-inhibited                   nil
      make-backup-files                  t
      auto-save-default                  t
      create-lockfiles                   nil
)
#+END_SRC
** TODO Auto save like in Intellij

Once the file backup is finished, auto save current buffer on:
- window change
- frame change
- focus lost (how to do that in terminal)
- after a timeout

** Use UTF-8

I guess all this is trying to say to use UTF-8 by default.

#+BEGIN_SRC emacs-lisp
(setq
      locale-coding-system          'utf-8
      default-process-coding-system '(utf-8-unix . utf-8-unix)
)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)
(set-language-environment 'utf-8)
(prefer-coding-system 'utf-8)
#+END_SRC

** Sensible defaults

Taken mostly from the [[https://github.com/hrs/sensible-defaults.el/blob/master/sensible-defaults.el][sensible-defaults.el]] and [[http://www.emacs-bootstrap.com/][emacs-bootstrap]].

*** Yes/No confirmation

Answering just 'y' or 'n' will do

#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

*** Defaults

#+BEGIN_SRC emacs-lisp
(setq
      confirm-nonexistent-file-or-buffer  t
      ;; apropos searches more extensively
      apropos-do-all                      t
      ;; save existing clipboard into kill ring before replacing it
      save-interprogram-paste-before-kill t
      ;; when middle-clicking the mouse to yank from the clipboard, insert the text where point is, not where the mouse cursor is
      mouse-yank-at-point                 t
      require-final-newline               t
      visible-bell                        t
      ;; http://ergoemacs.org/emacs/emacs_stop_cursor_enter_prompt.html
      minibuffer-prompt-properties        '(read-only t point-entered minibuffer-avoid-prompt face minibuffer-prompt)
      ;; Disable non selected window highlight
      cursor-in-non-selected-windows      nil
      highlight-nonselected-windows       nil
      ;; PATH
      exec-path                           (append exec-path '("/usr/local/bin/"))
      ;; single space to indicate end of a sentance
      sentence-end-double-space           nil
      x-select-enable-clipboard           t
      ;; use forward slashes in the unique buffer name
      uniquify-buffer-name-style          'forward
      ;; -i gets alias definitions from shell
      shell-command-switch                "-ic"
      echo-keystrokes                     0.1
      recentf-max-saved-items             100
      scroll-step                         1
      use-dialog-box                      nil
      kill-ring-max                       300
      initial-major-mode                  'text-mode
      cursor-in-non-selected-windows      t
      ;; when opening a file, follow symlinks
      vc-follow-symlinks                  t
      scroll-error-top-bottom             t
)

(setq-default
      tab-width                           2
      indent-tabs-mode                    nil
      ;; maximum line width
      fill-column                         79
      ;; don't fold lines
      truncate-lines                      t
      frame-title-format                  '("%b")
      indicate-empty-lines                t
      cursor-type                         'bar
      display-line-numbers-grow-only      t
      display-line-numbers-width-start    t
      show-paren-delay                    0.0
)

(blink-cursor-mode -1)
(delete-selection-mode t)
(show-paren-mode t)
(column-number-mode t)
(global-visual-line-mode t)
(global-hl-line-mode t)
;; when something changes a file, automatically refresh the buffer containing
;; that file so they can't get out of sync.
(global-auto-revert-mode t)
(transient-mark-mode t)
(toggle-truncate-lines t)
(whitespace-mode -1)

(diminish 'visual-line-mode " ↩")

(add-hook 'prog-mode-hook #'display-line-numbers-mode)
(add-hook 'text-mode-hook #'display-line-numbers-mode)
#+END_SRC

*** Turn on syntax highlighting whenever possible

#+begin_src emacs-lisp
(global-font-lock-mode t)
#+end_src

*** When saving a file that starts with =#!=, make it executable

#+BEGIN_SRC emacs-lisp
(add-hook 'after-save-hook
          'executable-make-buffer-file-executable-if-script-p)
#+END_SRC

*** TODO popwin
* Editing
** Deleting spaces

| Key     | Description                                                | Function                 |
|---------+------------------------------------------------------------+--------------------------|
| =M-\=   | Delete all spaces and tabs around point                    | =delete-horizonal-space= |
| =M-SPC= | Delete all spaces and tabs around point, leaving one space | =just-one-space=         |

** Copy and paste
*** Functions

These functions allow to C&P to the system clipboard using either terminal
escape code or xsel command if running in GUI.

#+BEGIN_SRC emacs-lisp
(defun fikovnik/copy-to-xclipboard ()
  (interactive)
  (if (use-region-p)
      (if (not (display-graphic-p))
          (letrec ((s (buffer-substring-no-properties (region-beginning) (region-end)))
                   (s-length (+ (* (length s) 3) 2)))
            (if (<= s-length 16384) ; magic number set to the same as ESC_BUF_SIZ of suckless termial (st.c)
                (progn
                  (send-string-to-terminal (concat "\e]52;c;"
                                                   (base64-encode-string (encode-coding-string s 'utf-8) t)
                                                   "\07"))
                  (message "Yanked region to terminal clipboard")
                  (deactivate-mark))
              (message "Selection too long (%d) to send to terminal." s-length)))
        (if (= 0 (shell-command-on-region (region-beginning) (region-end) "xsel -i -b"))
            (message "Yanked region to X-clipboard")
          (error "Is program `xsel' installed?")))
    (message "Nothing to yank to terminal clipboard")))

(defun fikovnik/cut-to-xclipboard ()
  (interactive)
  (my-copy-to-xclipboard)
  (kill-region (region-beginning) (region-end)))

(defun fikovnik/paste-from-xclipboard ()
  "Uses shell command `xsel -o' to paste from x-clipboard. With
one prefix arg, pastes from X-PRIMARY, and with two prefix args,
pastes from X-SECONDARY."
  (interactive)
  (if (display-graphic-p)
      (clipboard-yank)
    (letrec
        ((opt (prefix-numeric-value current-prefix-arg))
         (opt (cond
               ((=  1 opt) "b")
               ((=  4 opt) "p")
               ((= 16 opt) "s"))))
(insert (shell-command-to-string (concat "xsel -o -" opt))))))
#+END_SRC

*** Bind keys

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-S-x") 'fikovnik/cut-to-xclipboard)
(global-set-key (kbd "C-S-c") 'fikovnik/copy-to-xclipboard)
(global-set-key (kbd "C-S-v") 'fikovnik/paste-from-xclipboard)
#+END_SRC

** Fill/unfill paragraph

#+BEGIN_SRC emacs-lisp
(use-package unfill
  :defer t
  :commands (unfill-region unfill-paragraph unfill-toggle)
  :bind
  ([remap fill-paragraph] . unfill-toggle))
#+END_SRC

** Multiple cursors

#+BEGIN_SRC emacs-lisp
(global-unset-key (kbd "M-m"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
  :ensure t
  :config
  (smartrep-define-key global-map "M-m"
    '(("n" . 'mc/mark-next-like-this)
      ("u" . 'mc/unmark-next-like-this)
      ("s" . 'mc/skip-to-next-like-this)
      ("N" . 'mc/mark-previous-like-this)
      ("U" . 'mc/unmark-previous-like-this)
      ("S" . 'mc/skip-to-previous-like-this)
      ;; TODO: this should be (er/mark-word) followed by (mc/hydra)
      ("m" . 'mc/mark-more-like-this-extended)
      ("a" . 'mc/mark-all-like-this)
      ("d" . 'mc/mark-all-like-this-dwim)
      ("r" . 'mc/reverse-regions))))
#+END_SRC

** Move lines up / down
*** TODO fix this in org-mode which takes over this binding

#+BEGIN_SRC emacs-lisp
(use-package move-dup
  :ensure t
  :defer t
  :bind
  ("M-<up>" . md-move-lines-up)
  ("M-<down>" . md-move-lines-down)
  ("M-S-<up>" . md-duplicate-up)
  ("M-S-<down>" . md-duplicate-down))
#+END_SRC

** Join lines

The =join-line= command (aliased to =delete-indentation=) works from the last
line to be joined upwards. I prefer the other way around (cf. [[https://emacsredux.com/blog/2013/05/30/joining-lines/][here]]).

#+BEGIN_SRC emacs-lisp
(defun fikovnik/join-line ()
  "Join the current line with the line beneath it."
  (interactive)
  (delete-indentation 1))
#+END_SRC

| Key   | Description                                       |
|-------+---------------------------------------------------|
| =M-j= | Join the current line with the line *beneath* it. |
| =M-J= | Join the current line with the line *over* it.    |

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-j") 'fikovnik/join-line)
(global-set-key (kbd "M-J") 'join-line)
#+END_SRC

** Open line above / bellow

| Key     | Description                                        |
|---------+----------------------------------------------------|
| =C-PEM= | To insert a blank line *above* the line you're on. |
| =C-EM=  | To insert a blank line *below* the line you're on. |

** Comment / un-comment lines
*** Functions
First, define a function taken from [[https://stackoverflow.com/a/11517584/219584][here]]:

#+BEGIN_SRC emacs-lisp
(defun fikovnik/comment-or-uncomment-line-or-region ()
  "Comments or uncomments the current line or region."
  (interactive)
  (if (region-active-p)
      (comment-or-uncomment-region (region-beginning) (region-end))
    (comment-or-uncomment-region (line-beginning-position) (line-end-position))))
#+END_SRC

*** Binding
**** TODO this does not work so far, because in the terminal =C-;= is seen as =;= only.

#+BEGIN_SRC emacs-lisp
(global-unset-key (kbd "C-;"))
(global-set-key (kbd "C-;") 'fikovnik/comment-or-uncomment-line-or-region)
#+END_SRC

** Whole line

The following [[https://emacs.stackexchange.com/questions/2347/kill-or-copy-current-line-with-minimal-keystrokes][snippet]] changes the behavior of:
- =C-w=: with no active region, kill a single line instead
- =M-w=: with no active region, copy a single line instead

#+BEGIN_SRC emacs-lisp
(defun fikovnik/slick-cut (beg end)
  (interactive
   (if mark-active
       (list (region-beginning) (region-end))
     (list (line-beginning-position) (line-beginning-position 2)))))

(advice-add 'kill-region :before #'fikovnik/slick-cut)

(defun fikovnik/slick-copy (beg end)
  (interactive
   (if mark-active
       (list (region-beginning) (region-end))
     (message "Copied line")
     (list (line-beginning-position) (line-beginning-position 2)))))

(advice-add 'kill-ring-save :before #'fikovnik/slick-copy)
#+END_SRC
** Expand region (=M-r=)

Define a function that simply selects the current line.

#+BEGIN_SRC emacs-lisp
(defun fikovnik/select-line ()
  "Select current line. If region is active, extend selection downward by line."
  (interactive)
  (if (region-active-p)
      (progn
        (forward-line 1)
        (end-of-line))
    (progn
      (end-of-line)
      (set-mark (line-beginning-position)))))
#+END_SRC

Define the =M-r= prefix and use it for expand region, including the line
selection defined above.

#+BEGIN_SRC emacs-lisp
(global-unset-key (kbd "M-r"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :ensure t
  :bind
  (("M-r m"  . er/expand-region)
   ("M-r ("  . er/mark-inside-pairs)
   ("M-r )"  . er/mark-outside-pairs)
   ("M-r '"  . er/mark-inside-quotes)
   ("M-r \"" . er/mark-outside-quotes) ; it's just a quotation mark
   ("M-r o" . er/mark-org-parent)
   ("M-r u" . er/mark-url)
   ("M-r b" . er/mark-org-code-block)
   ("M-r ." . er/mark-method-call)
   ("M-r >" . er/mark-next-accessor)
   ("M-r w" . er/mark-word)
   ("M-r d" . er/mark-defun)
   ("M-r e" . er/mark-email)
   ("M-r ," . er/mark-symbol)
   ("M-r <" . er/mark-symbol-with-prefix)
   ("M-r ;" . er/mark-comment)
   ("M-r s" . er/mark-sentence)
   ("M-r S" . er/mark-text-sentence)
   ("M-r p" . er/mark-paragraph)
   ("M-r P" . er/mark-text-paragraph)
   ("M-r l" . fikovnik/select-line)))
#+END_SRC

** Snippets
#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :ensure t
  :init
  (yas-global-mode 1))
#+end_src
** Auto completion

#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  :config
  (add-hook 'after-init-hook 'global-company-mode))
#+END_SRC
*** TODO [[https://github.com/expez/company-quickhelp][company-quick-help]]

** TODO delete syntax
** TODO spell checking
** TODO surround
- https://github.com/ganmacs/emacs-surround
** TODO rainbow parameters
** TODO smartparens
** TODO zap to char
- M-z
- M-Z
* Movement and navigation
** Windows (=C-x w=)
*** Overview

| Key         | Description                          | Function      |
|-------------+--------------------------------------+---------------|
| =C-c left=  | Undo changes in window configuration | =winner-undo= |
| =C-c right= | Redo changes in window configuration | =winner-redo= |
| =C-x o=     | Select window using Avy              | =ace-window=  |

*** Selecting windows
Windmove defines functions to easily select windows. We do not use the default
keybinding, instead it is bound by the =hydra-window=.

#+BEGIN_SRC emacs-lisp
(use-package windmove
  :ensure t
  :custom
  (windmove-wrap-around t))
#+END_SRC

*** Save window layout stack using the =winner-mode=

This will allow to go back/fort between window layouts.

#+BEGIN_SRC emacs-lisp
(use-package winner
  :ensure t
  :config
  (winner-mode 1))
#+END_SRC

*** Jump between windows

Use [[https://github.com/abo-abo/ace-window][ace-window]] to quickly switch between windows using =C-x o= instead of the
default =other-window= command.

#+BEGIN_SRC emacs-lisp
(use-package ace-window
  :ensure t
  :defer t
  :custom
  (aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
  (aw-dispatch-always nil)
  (aw-dispatch-alist
   '((?x aw-delete-window     "Delete Window")
	   (?S aw-swap-window       "Swap Windows")
	   (?m aw-maximize-window   "Maximize Window")
     (?M aw-move-window       "Move Window")
	   (?c aw-copy-window       "Copy Window")
	   (?= aw-split-window-fair "Split Fair Window")
	   (?- aw-split-window-vert "Split Vert Window")
	   (?| aw-split-window-horz "Split Horz Window")
	   (?? aw-show-dispatch-help)))
  :config
  (set-face-attribute 'aw-leading-char-face nil :weight 'bold)
  :bind
  ([remap other-window] . ace-window))
#+END_SRC

*** Setup =C-x w= micro state                                       :hydra:
**** Functions
Define a function to [[https://gist.github.com/3402786][maximize window]].

#+BEGIN_SRC emacs-lisp
(defun fikovnik/maximize-window ()
  (interactive)
  (if (and (= 1 (length (window-list)))
           (assoc ?_ register-alist))
      (jump-to-register ?_)
    (progn
      (window-configuration-to-register ?_)
      (delete-other-windows))))
#+END_SRC

**** Hydra

#+BEGIN_SRC emacs-lisp
(defhydra hydra-window (:hint nil)
   "
   ^Select^    ^Split^           ^Switch^           ^Resize^      ^Misc^
  -----------------------------------------------------------------------
      _↑_      _-_: vertical     _b_uffer             ⇧         _u_ndo/_r_edo
    _←_   _→_    _|_: horizontal   _f_ind files       ⇦   ⇨       _a_ce-window
      _↓_      ^ ^               _s_wap               ⇩         _d_elete/ace-_D_elete
   ^ ^         ^ ^               _m_aximize/_B_alance
"
   ("<left>" windmove-left)
   ("<down>" windmove-down)
   ("<up>" windmove-up)
   ("<right>" windmove-right)
   ("S-<left>" shrink-window-horizontally)
   ("S-<down>" enlarge-window)
   ("S-<up>" shrink-window)
   ("S-<right>" enlarge-window-horizontally)
   ("b" helm-mini :color blue)
   ("f" helm-find-files :color blue)
   ("a" ace-window :color blue)
   ("|" (lambda ()
          (interactive)
          (split-window-right)
          (windmove-right)))
   ("-" (lambda ()
          (interactive)
          (split-window-below)
          (windmove-down)))
   ("s" (lambda ()
          (interactive)
          (ace-window 4)
          (add-hook 'ace-window-end-once-hook
                    'hydra-window/body)))
   ("d" kill-buffer-and-window :color blue)
   ("D" ace-delete-window)
   ("m" fikovnik/maximize-window :color blue)
   ("B" balance-windows-area)
   ("u" (progn
          (winner-undo)
          (setq this-command 'winner-undo)))
   ("r" winner-redo)
   ("q" nil :color blue))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x w") 'hydra-window/body)
#+END_SRC
** Go to (=M-q=)
*** Setup Avy

This allows to quickly jump around in the buffer. The way it is setup is by
remapping the =M-g= to a hydra that calls various [[https://github.com/abo-abo/avy][avy]] functions.

#+BEGIN_SRC emacs-lisp
(global-unset-key (kbd "M-g"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package avy
  :ensure t
  :bind
  ("M-g" . hydra-avy/body)
  :config
  (avy-setup-default)
  (set-face-attribute 'avy-lead-face-0 nil :foreground "black"))
#+END_SRC

*** Setup =M-g= micro state                                         :hydra:

#+BEGIN_SRC emacs-lisp
(defhydra hydra-goto (:exit t :hint nil :color blue)
  "
   ^Line^   ^Region^   ^Goto^
  ----------------------------------------------------------
   _y_ank   _Y_ank     timed _c_har  _C_har
   _m_ove   _M_ove     _w_ord        any _W_ord
   _k_ill   _K_ill     _l_ine        end of _L_ine  _g_: line number"
  ("g" goto-line)
  ("c" avy-goto-char-timer)
  ("C" avy-goto-char)
  ("w" avy-goto-word-1)
  ("W" avy-goto-word-0)
  ("l" avy-goto-line)
  ("L" avy-goto-end-of-line)
  ("m" avy-move-line)
  ("M" avy-move-region)
  ("k" avy-kill-whole-line)
  ("K" avy-kill-region)
  ("y" avy-copy-line)
  ("Y" avy-copy-region)
  ("q" nil))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-g") 'hydra-goto/body)
#+END_SRC

*** TODO next error / previous error

** Buffers (=C-x b=)
*** Functions

#+BEGIN_SRC emacs-lisp
(defun fikovnik/new-empty-buffer ()
  "Create a new buffer called untitled(<n>)."
  (interactive)
  (let ((newbuf (generate-new-buffer "untitled")))
    (with-current-buffer newbuf
      (setq-local buffer-offer-save t))
    (switch-to-buffer newbuf nil 'force-same-window)))
#+END_SRC

*** Setup =C-x b= micro state                                       :hydra:
**** TODO switch to messages buffer
**** TODO switch to scratch buffer

#+BEGIN_SRC emacs-lisp
(defhydra hydra-buffers (:exit t :hint nil)
("b" helm-mini "list")
("n" next-buffer "next")
("p" previous-buffer "previous")
("k" kill-buffer "kill")
("x" kill-buffer-and-window "close")
("R" revert-buffer "revert")
("N" fikovnik/new-empty-buffer "new")
("i" ibuffer "ibuffer")
)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x b") 'hydra-buffers/body)
#+END_SRC
** TODO pgup/pgdown go to the same location
** TODO Go to matching paren
** TODO Gentle navigation
** TODO highlight symbols (=*=, =#=)
- https://github.com/nschum/highlight-symbol.el
** TODO move to previous/next edit location
** TODO ace-link
- https://github.com/abo-abo/ace-link
** =C-a= / =home= and =C-e= / =end= keys move to the beginning/end of the line smartly

#+BEGIN_SRC emacs-lisp
(use-package mwim
  :ensure t
  :defer t
  :bind
  ("C-a" . mwim-beginning)
  ("C-e" . mwim-end)
  ("<home>" . mwim-beginning)
  ("<end>" . mwim-end))
#+END_SRC

** Helm
*** Functions

#+BEGIN_SRC emacs-lisp
(defun fikovnik/helm-hide-minibuffer-maybe ()
  "Hide minibuffer in Helm session if we use the header line as input field."
  (when (with-helm-buffer helm-echo-input-in-header-line)
    (let ((ov (make-overlay (point-min) (point-max) nil nil t)))
      (overlay-put ov 'window (selected-window))
      (overlay-put ov 'face
                   (let ((bg-color (face-background 'default nil)))
                     `(:background ,bg-color :foreground ,bg-color)))
      (setq-local cursor-type nil))))
#+END_SRC

*** Basics

#+BEGIN_SRC emacs-lisp
(use-package helm
  :ensure t
  :custom
  (helm-echo-input-in-header-line        t)
  (helm-ff-file-name-history-use-recentf t)
  (helm-ff-skip-boring-files             t)
  (helm-M-x-fuzzy-match                  t)
  (helm-buffers-fuzzy-matching           t)
  (helm-recentf-fuzzy-match              t)
  (helm-split-window-in-side-p           t)
  (helm-split-window-default-side        'below)
  (helm-move-to-line-cycle-in-source     t)
  (helm-idle-delay                       0.0)
  (helm-input-idle-delay                 0.01)
  (helm-quick-update                     t)
  (helm-autoresize-max-height            0)
  (helm-autoresize-min-height            20)
  :config
  (helm-autoresize-mode 1)
  (helm-mode 1)
  :hook
  (helm-minibuffer-set-up-hook . fikovnik/helm-hide-minibuffer-maybe)
  :bind
  (("M-x" . helm-M-x)
  ("C-x C-f" . helm-find-files)
  ("C-x p l" . helm-projectile)
  ("C-x c o" . helm-occur)
  ("C-x c /" . helm-projectile-ag)
  ("C-x c k" . helm-show-kill-ring)
  ("M-i" . helm-imenu)
  :map helm-map
  ("<tab>" . helm-execute-persistent-action) ; rebind tab to do persistent action
  ("C-i" . helm-execute-persistent-action) ; make TAB works in terminal
  ("C-z" . helm-select-action) ; list actions using C-z
  ))
#+END_SRC

*** Searching with =helm-ag=

#+BEGIN_SRC emacs-lisp
(use-package helm-ag
  :ensure t
  :custom
  (helm-ag-base-command "rg --no-heading"))
#+END_SRC

*** Project files with =helm-ls-git=
**** TODO how is this connected to [[https://github.com/bbatsov/helm-projectile][helm-projectile]]?

#+BEGIN_SRC emacs-lisp
(use-package helm-ls-git
  :ensure t
  :defer t
  :bind
  ("C-x p f" . helm-browse-project))
#+END_SRC
*** Describe bindings

#+BEGIN_SRC emacs-lisp
(use-package helm-descbinds
  :ensure t
  :defer t
  :bind
  ([remap describe-bindings] . helm-descbinds))
#+END_SRC

*** Other
**** TODO helm-dictionary
**** TODO helm-addressbook / helm-mu
**** TODO helm-c-yasnippet
**** TODO imenu-anywhere
**** TODO helm-bibtex
**** TODO helm-dash
**** helm-xref

#+BEGIN_SRC emacs-lisp
(use-package helm-xref
  :ensure t
  :defer t
  :commands helm-xref-show-xrefs
  :custom
  (xref-show-xrefs-function 'helm-xref-show-xrefs))
#+END_SRC

**** TODO helm-flycheck
**** TODO swiper-helm
**** TODO [[https://github.com/ShingoFukuyama/helm-swoop][helm-swoop]]
**** TODO helm-projectile
**** TODO helm-lsp
**** TODO https://github.com/ganmacs/emacs-surround
**** flyspell

#+BEGIN_SRC emacs-lisp
(use-package flyspell-correct-helm
  :bind ("C-M-;" . flyspell-correct-wrapper)
  :init
  (setq flyspell-correct-interface #'flyspell-correct-helm))
#+END_SRC

** TODO text objects
- https://github.com/clemera/objed
* Search and replace
** TODO search using swoop
- https://github.com/ShingoFukuyama/helm-swoop
** TODO replace
- is the visual regexp good enough?
* Toggles (=C-x t=)
** Setup =C-x t= micro state                                         :hydra:

#+BEGIN_SRC emacs-lisp
(defhydra hydra-toggle (:color blue :hint nil)
  "
[_a_] abbrev-mode:       %`abbrev-mode
[_d_] debug-on-error:    %`debug-on-error
[_f_] auto-fill-mode:    %`auto-fill-function
[_t_] truncate-lines:    %`truncate-lines
[_w_] whitespace-mode:   %`whitespace-mode
[_l_] org link display:  %`org-descriptive-links
"
  ("a" abbrev-mode)
  ("d" toggle-debug-on-error)
  ("f" auto-fill-mode)
  ("t" toggle-truncate-lines)
  ("w" whitespace-mode)
  ("l" org-toggle-link-display)
  ("q" nil "quit"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x t") 'hydra-toggle/body)
#+END_SRC
* TODO Mouse
* TODO Bookmarks

#+BEGIN_SRC
(setq
 ;; persistent bookmarks
 bookmark-save-flag                      t
 bookmark-default-file              (concat temp-dir "/bookmarks"))
#+END_SRC
* TODO Projects
* Packages
** iqa - quick access to config file

#+BEGIN_SRC emacs-lisp
(use-package iqa
  :ensure t
  :custom
  (iqa-user-init-file (concat user-emacs-directory "config.org"))
  :config
  (iqa-setup-default))
#+END_SRC

** ibuffers

#+BEGIN_SRC emacs-lisp
(use-package ibuffer
  :bind
  ([remap list-buffers] . ibuffer))
#+END_SRC

**** TODO hydra
- https://github.com/abo-abo/hydra#the-impressive-looking-one
** which-key

#+BEGIN_SRC emacs-lisp
(use-package which-key
  :diminish which-key-mode
  :custom
  (which-key-idle-delay 0.3)
  :config
  (which-key-mode))
#+END_SRC

** dired
*** Settings

Auto refresh dired
#+BEGIN_SRC emacs-lisp
(add-hook 'dired-mode-hook 'auto-revert-mode)
(setq
      global-auto-revert-non-file-buffers t
      auto-revert-verbose                 nil
      ;; file sizes in human-readable units (KB, MB, etc)
      dired-listing-switches              "-alh"
)
#+END_SRC

*** TODO hydra
** info
*** TODO hydra
** diff

#+BEGIN_SRC emacs-lisp
(use-package ediff
  :config
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
  (setq-default ediff-highlight-all-diffs 'nil)
  (setq ediff-diff-options "-w"))
#+END_SRC

* Version control
** Sort buffers in ibuffer based on git

#+BEGIN_SRC emacs-lisp
(use-package ibuffer-vc
  :ensure t)
#+END_SRC

** Magit

#+BEGIN_SRC emacs-lisp
(use-package magit
  :defer t
  :ensure t
  :custom
  (magit-display-buffer-function 'magit-display-buffer-fullframe-status-v1 "Enable fullscreen")
  :bind
  ("C-x g" . magit-status)
  ("C-x M-g" . fikovnik/dotfiles-magit))

(use-package magit-popup
  :ensure t)
#+END_SRC

** Highlight chnages in files

#+BEGIN_SRC emacs-lisp
(use-package diff-hl
  :ensure t
  :hook
  ((magit-post-refresh . diff-hl-magit-post-refresh)
   (prog-mode . diff-hl-mode)
   (prog-mode . diff-hl-margin-mode)
   (org-mode . diff-hl-mode)
   (org-mode . diff-hl-margin-mode)
   (dired-mode . diff-hl-dired-mode)))
#+END_SRC

** Support for my local dot-file config

I use git to version my dot files. While there are many options for managing
them such as [[https://github.com/RichiH/vcsh][vcsh]], I prefer the simplest possible, just using git and nothing
else. The trick is to separate work tree and git directory. While this work
well, magit does not understand this and has to have the relevant =--work-tree=
and =--git-dir= options explicitly set. For this I define a new function
=fikovnik/dotfiles-magit= which tries to do that.

#+BEGIN_SRC emacs-lisp
(defconst fikovnik/dotfiles-git-dir (expand-file-name "~/.dotfiles"))

(defun fikovnik/-dotfiles-remove-magit-config (&optional kill)
  (setq magit-git-global-arguments
        (remove (format "--work-tree=%s" (getenv "HOME")) magit-git-global-arguments))
  (setq magit-git-global-arguments
        (remove (format "--git-dir=%s" fikovnik/dotfiles-git-dir) magit-git-global-arguments))
  (advice-remove 'magit-mode-bury-buffer #'fikovnik/-dotfiles-remove-magit-config))

(defun fikovnik/dotfiles-magit ()
  (interactive)
  (when (and (boundp 'magit-git-global-arguments)
             (file-exists-p fikovnik/dotfiles-git-dir))
    (let ((home (getenv "HOME")))
      (add-to-list 'magit-git-global-arguments
                   (format "--work-tree=%s" home))
      (add-to-list 'magit-git-global-arguments
                   (format "--git-dir=%s" fikovnik/dotfiles-git-dir))
      (advice-add 'magit-mode-bury-buffer :after #'fikovnik/-dotfiles-remove-magit-config)
      (magit-status-setup-buffer home))))
#+END_SRC

* Org
** Default setup

#+BEGIN_SRC emacs-lisp
(use-package org
  :defer t
  ;; to be sure we have the latest Org version
  :ensure org-plus-contrib
  :hook
  (org-mode . flyspell-mode)
  :custom
  (org-src-tab-acts-natively t)
  (org-src-preserve-indentation t)
  (org-log-done t)
  (org-startup-with-inline-images t)
  (org-latex-prefer-user-labels t)
  (org-image-actual-width nil)
  (org-id-link-to-org-use-id 'create-if-interactive)
  (org-agenda-files '("~/Notes/Journal"))
  (org-directory "~/Notes")
  (org-default-notes-file "~/Notes/Journal/Notes.org")
  (org-startup-indented 1)
  (org-blank-before-new-entry '(((heading .  t) (plain-list-item . t))))
  (org-log-reschedule 'time)
  (org-log-into-drawer t)
  (org-refile-targets (quote ((nil :maxlevel . 9) (org-agenda-files :maxlevel . 9))))
  (org-src-fontify-natively t)
  (org-todo-keywords '((sequence "TODO(t)" "WAIT(w@/!)" "|" "DONE(d!)" "CANCELED(c@)")))
  (org-capture-templates
     '(("t" "Todo"         entry (file+headline "~/Notes/Journal/TODO.org" "INBOX")  "* TODO %?\ncaptured on: %U\nfrom: %a\n%i")
       ("n" "Note"         entry (file+headline "~/Notes/Journal/Notes.org" "Notes") "* %?\ncaptured on: %U\nfrom: %a\n%i")
       ("j" "Journal"      entry (file+datetree "~/Notes/Journal/Journal.org")    "* %?\n%i")
       ("J" "Work Journal" entry (file+datetree "~/Notes/Journal/Work.org")  "* %?\n%i")))
  :bind
  ("C-c c" . org-capture))
#+END_SRC

** Better appearance

#+BEGIN_SRC emacs-lisp
(use-package org-bullets
  :ensure t
  :custom
  (org-bullets-bullet-list '("•"))
  (org-ellipsis "↴")
  :hook
  (org-mode . org-bullets-mode))
#+END_SRC

** Yasnippet support

From [[https://orgmode.org/worg/org-faq.html#YASnippet][org-manual]]:
#+begin_quote
The way Org-mode binds the TAB key (binding to [tab] instead of \t) overrules yasnippets' access to this key.
#+end_quote

The following is the _official_ way to fix it:

#+BEGIN_SRC emacs-lisp
(defun yas/org-very-safe-expand ()
  (let ((yas/fallback-behavior 'return-nil)) (yas/expand)))

(add-hook 'org-mode-hook
          (lambda ()
            (make-variable-buffer-local 'yas/trigger-key)
            (setq yas/trigger-key [tab])
            (add-to-list 'org-tab-first-hook 'yas/org-very-safe-expand)
            (define-key yas/keymap [tab] 'yas/next-field)))
#+END_SRC
** TODO org-ref
** TODO images
- https://github.com/abo-abo/org-download
* Languages
** General
*** Enable [[https://github.com/flycheck/flycheck][flycheck]]

#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :ensure t
  :init (global-flycheck-mode))
#+END_SRC

*** Enable LSP

#+BEGIN_SRC emacs-lisp
(use-package lsp-mode
  :ensure t
  :defer t
  :custom
  (lsp-prefer-flymake nil)
  :commands lsp)

(use-package lsp-ui
  :ensure t
  :defer t
  :commands lsp-ui-mode)

(use-package company-lsp
  :ensure t
  :defer t
  :custom
  (company-transformers nil)
  (company-lsp-async t)
  (company-lsp-cache-candidates nil)
  :commands company-lsp)
#+END_SRC

| Key     | Description      | Function                |
|---------+------------------+-------------------------|
| =M-.=   | Find definitions | =xref-find-definitions= |
| =M-?=   | Find references  | =xref-find-references=  |
| =C-M-.= |                  | =xref-find-apropos=     |

*** TODO enable [[https://github.com/emacs-lsp/dap-mode][dap]]
** C/C++
*** Backend

Use [[https://github.com/MaskRay/ccls/wiki/lsp-mode][ccls]] as the backend for C/C++.

#+BEGIN_SRC emacs-lisp
(use-package ccls
  :ensure t
  :defer t
  :custom
  (ccls-initialization-options '(:index (:comments 2) :completion (:detailedLabel t)))
  ;; no semantic highlighting
  (ccls-sem-highlight-method nil)
  :config
  (setq-default flycheck-disabled-checkers '(c/c++-clang c/c++-cppcheck c/c++-gcc))
  :hook
  ((c-mode c++-mode objc-mode) . (lambda () (require 'ccls) (lsp))))
#+END_SRC

Not sure why it is needed, but without I get =lsp--location-to-td-position:
Wrong type argument: hash-table-p, nil=, cf. [[https://github.com/MaskRay/emacs-ccls/issues/17][emacs-ccls:#17]]

#+BEGIN_SRC emacs-lisp
(setq xref-prompt-for-identifier
      '(not xref-find-definitions
            xref-find-definitions-other-window
            xref-find-definitions-other-frame
            xref-find-references))
#+END_SRC

*** TODO Semantic movement

Bind these to some keys?

#+BEGIN_SRC emacs-lisp :tangle no
(ccls-navigate "D") ;; roughly sp-down-sexp
(ccls-navigate "L")
(ccls-navigate "R")
(ccls-navigate "U")
#+END_SRC

*** TODO C++ hierarchy
ccls-member-hierarchy $ccls/member hierarchy:true

(ccls-call-hierarchy nil) ; caller hierarchy
(ccls-call-hierarchy t) ; callee hierarchy

$ccls/call

(ccls-inheritance-hierarchy nil) ; base hierarchy
(ccls-inheritance-hierarchy t) ; derived hierarchy

** TODO scala
- just code highlighting
** TODO R
- ESS or lsp
* Applications
** TODO agenda / calendar
** TODO email
** TODO elfeed
- https://github.com/abo-abo/elfeed
* Appearance
** Theme

#+BEGIN_SRC emacs-lisp
(use-package base16-theme
  :ensure t
  :config
  (load-theme 'base16-oceanicnext t))
#+END_SRC

*** TODO better contrast between hl-line and region
** Font

TODO: font size hydra

#+BEGIN_SRC emacs-lisp
(add-to-list 'default-frame-alist
  (cond
    ((string-equal system-type "darwin")    '(font . "dejavu sans mono"))
    ((string-equal system-type "gnu/linux") '(font . "dejavu sans mono"))))
#+END_SRC

** Modeline
*** TODO better modeline?
- if so look at [[https://github.com/seagle0128/doom-modeline][doom-modeline]]
#+BEGIN_SRC emacs-lisp :tangle no
(use-package doom-modeline
  :ensure t
  :hook
  (after-init . doom-modeline-init)
  :custom
  (doom-modeline-major-mode-icon t)
  (doom-modeline-buffer-file-name-style 'buffer-name)
  (doom-modeline-icon t))
#+END_SRC
** Cursor
*** TODO bar cursor
*** TODO pink cursor
** Colors
*** TODO better TODO colors
* Troubleshooting
** Invalid function: =org-preserve-local-variables=

As indicated in [[https://github.com/syl20bnr/spacemacs/issues/11801#issuecomment-451755821][spacemacs/11801]], the problem is in version misalignment which
can be fixed by removing all =org-*/*.elc= files and compiling it again:

#+BEGIN_SRC sh
find org*/*.elc -print0 | xargs -0 rm
#+END_SRC

And then running the following function

#+BEGIN_SRC emacs-lisp
(defun fikovnik/recompile-elpa ()
  "Recompile packages in elpa directory. Useful if you switch
   Emacs versions."
  (interactive)
  (byte-recompile-directory package-user-dir nil t))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
(fikovnik/recompile-elpa)
#+END_SRC

** Unable to install a package

In the case a package installation from =(use-package)= fails due to a missing
file on MELPA, it might be due to an outdated local index. Use:

#+BEGIN_SRC emacs-lisp :tangle no
(package-refresh-contents)
#+END_SRC
